class Spirograph extends HTMLElement{get ratio(){return window.devicePixelRatio}get R(){return null===this._R?parseFloat(this.getAttribute("fixed-circle-radius")):this._R}set R(t){this._R=this.ratio*parseFloat(t),this.setAttribute("fixed-circle-radius",t)}get r(){return null===this._r?parseFloat(this.getAttribute("moving-circle-radius")):this._r}set r(t){this._r=this.ratio*parseFloat(t),this.setAttribute("moving-circle-radius",t)}get p(){return null===this._p?parseFloat(this.getAttribute("moving-circle-locus-length")):this._p}set p(t){this._p=this.ratio*parseFloat(t),this.setAttribute("moving-circle-locus-length",t)}get reps(){return null===this._reps?parseFloat(this.getAttribute("repeat-count")):this._reps}set reps(t){this._reps=parseFloat(t),this.setAttribute("repeat-count",t)}get frozen(){return null===this._frozen?this.getAttribute("frozen"):this._frozen}set frozen(t){this._frozen=t,this.setAttribute("frozen",t)}static get observedAttributes(){return["fixed-circle-radius","moving-circle-radius","moving-circle-locus-length","repeat-count","frozen"]}get vertexShaderSource(){return null===this._vertexShaderSource?"#version 300 es\n\n    // an attribute is an input (in) to a vertex shader.\n    // It will receive data from a buffer\n    in vec2 a_position;\n    \n    // Used to pass in the resolution of the canvas\n    uniform vec2 u_resolution;\n    \n    out vec4 v_color;\n\n    // all shaders have a main function\n    void main() {\n    \n      // convert the position from pixels to 0.0 to 1.0\n      vec2 zeroToOne = a_position / u_resolution;\n    \n      // convert from 0->1 to 0->2\n      vec2 zeroToTwo = zeroToOne * 2.0;\n    \n      // convert from 0->2 to -1->+1 (clipspace)\n      vec2 clipSpace = zeroToTwo - 1.0;\n    \n      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n\n      // Convert from clipspace to colorspace.\n      // Clipspace goes -1.0 to +1.0\n      // Colorspace goes from 0.0 to 1.0\n      v_color = vec4(1, gl_Position.xy, 1);\n    }\n    ":this._vertexShaderSource}set vertexShaderSource(t){this._vertexShaderSource=t,this.initializeWebGL()}get fragmentShaderSource(){return null===this._fragmentShaderSource?"#version 300 es\n  \n    precision mediump float;\n\n    in vec4 v_color;\n\n    uniform vec4 u_color;\n    \n    // we need to declare an output for the fragment shader\n    out vec4 outColor;\n    \n    void main() {\n      outColor = v_color;\n    }\n    ":this._fragmentShaderSource}set fragmentShaderSource(t){this._fragmentShaderSource=t,this.initializeWebGL()}constructor(){super(),this._R=null,this._p=null,this._r=null,this._reps=null,this._frozen=null,this._vertexShaderSource=null,this._fragmentShaderSource=null,this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="\n      <canvas data-canvas></canvas>\n      <style>\n      :host {\n        display: grid;\n      }\n      canvas {\n        width: 100%;\n        min-height: 100%;\n      }\n      ",this.initializeWebGL()}initializeWebGL(){const t=this.shadowRoot.querySelector("[data-canvas]");this.gl=t.getContext("webgl2"),this.program=this.getProgram(),this.gl.useProgram(this.program),this.positionAttributeLocation=this.gl.getAttribLocation(this.program,"a_position"),this.resolutionUniformLocation=this.gl.getUniformLocation(this.program,"u_resolution"),this.colorLocation=this.gl.getUniformLocation(this.program,"u_color");const e=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,e)}createSpirograph(t,e,r,i){const s=this.getSpirographPoints(t,e,r,i),o=s.length/2;this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(s),this.gl.STATIC_DRAW);const n=this.gl.createVertexArray();this.gl.bindVertexArray(n),this.gl.uniform2f(this.resolutionUniformLocation,this.gl.canvas.width,this.gl.canvas.height),this.gl.enableVertexAttribArray(this.positionAttributeLocation);const a=this.gl.FLOAT;this.gl.vertexAttribPointer(this.positionAttributeLocation,2,a,!1,0,0),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.clearColor(0,0,0,0),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(n),this.gl.uniform4f(this.colorLocation,.1,.2,.1,1);const h=this.gl.LINE_STRIP,l=o;this.gl.drawArrays(h,0,l)}getProgram(){const t=this.createShader(this.gl,this.gl.VERTEX_SHADER,this.vertexShaderSource),e=this.createShader(this.gl,this.gl.FRAGMENT_SHADER,this.fragmentShaderSource);return this.createProgram(this.gl,t,e)}createShader(t,e,r){const i=t.createShader(e);if(t.shaderSource(i,r),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS))return i;t.deleteShader(i)}createProgram(t,e,r){const i=t.createProgram();if(t.attachShader(i,e),t.attachShader(i,r),t.linkProgram(i),t.getProgramParameter(i,t.LINK_STATUS))return i;console.log(t.getProgramInfoLog(i)),t.deleteProgram(i)}resize(t){const e=window.devicePixelRatio||1,r=Math.floor(t.clientWidth*e),i=Math.floor(t.clientHeight*e);t.width===r&&t.height===i||(t.width=r,t.height=i)}connectedCallback(){this.resize(this.gl.canvas),this.createSpirographFromAttributes()}createSpirographFromAttributes(){this.createSpirograph(this.R,this.r,this.p,this.reps)}render(){this.createSpirograph(this.R,this.r,this.p,this.reps)}attributeChangedCallback(t,e,r){this.frozen||this.createSpirographFromAttributes()}range(t,e,r){if(void 0===e&&(e=t,t=0),void 0===r&&(r=1),r>0&&t>=e||r<0&&t<=e)return[];var i=[];for(let s=t;r>0?s<e:s>e;s+=r)i.push(s);return i}disconnectedCallback(){}simplifyPoints(t,e,r,i,s){const o=s||[],n=t[e],a=t[r-1];let h=0,l=1;for(let i=e+1;i<r-1;++i){const e=this.distanceToSegmentSq(t[i],n,a);e>h&&(h=e,l=i)}return Math.sqrt(h)>i?(this.simplifyPoints(t,e,l+1,i,o),this.simplifyPoints(t,l,r,i,o)):o.push(n,a),o}distanceToSegmentSq(t,e,r){const i=this.distanceSq(e,r);if(0===i)return this.distanceSq(t,e);let s=((t[0]-e[0])*(r[0]-e[0])+(t[1]-e[1])*(r[1]-e[1]))/i;return s=Math.max(0,Math.min(1,s)),this.distanceSq(t,this.lerp(e,r,s))}lerp(t,e,r){return[t[0]+(e[0]-t[0])*r,t[1]+(e[1]-t[1])*r]}distanceSq(t,e){const r=t[0]-e[0],i=t[1]-e[1];return r*r+i*i}getSpirographPoints(t,e,r,i){const s=i=>(t+e)*Math.cos(i)+r*Math.cos((t+e)*(i/e)),o=i=>(t+e)*Math.sin(i)+r*Math.sin((t+e)*(i/e)),n=this.gl.canvas.width,a=this.gl.canvas.height,h=this.range(0,i,.005).map(t=>[s(t)+n/2,o(t)+a/2]);return this.simplifyPoints(h,0,h.length,1).flat()}}customElements.define("mm-spirograph",Spirograph);