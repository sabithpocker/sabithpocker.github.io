class Spirograph extends HTMLElement{get ratio(){return window.devicePixelRatio}get R(){return null===this._R?parseFloat(this.getAttribute("fixed-circle-radius")):this._R}set R(t){this._R=this.ratio*parseFloat(t),this.setAttribute("fixed-circle-radius",t)}get r(){return null===this._r?parseFloat(this.getAttribute("moving-circle-radius")):this._r}set r(t){this._r=this.ratio*parseFloat(t),this.setAttribute("moving-circle-radius",t)}get p(){return null===this._p?parseFloat(this.getAttribute("moving-circle-locus-length")):this._p}set p(t){this._p=this.ratio*parseFloat(t),this.setAttribute("moving-circle-locus-length",t)}get reps(){return null===this._reps?parseFloat(this.getAttribute("repeat-count")):this._reps}set reps(t){this._reps=parseFloat(t),this.setAttribute("repeat-count",t)}get density(){return null===this._density?parseFloat(this.getAttribute("density")):this._density}set density(t){this._density=parseFloat(t),this.setAttribute("density",t)}get frozen(){return null===this._frozen?this.getAttribute("frozen"):this._frozen}set frozen(t){this._frozen=t,this.setAttribute("frozen",t)}static get observedAttributes(){return["fixed-circle-radius","moving-circle-radius","moving-circle-locus-length","repeat-count","frozen"]}get vertexShaderSource(){return null===this._vertexShaderSource?"#version 300 es\n\n    // an attribute is an input (in) to a vertex shader.\n    // It will receive data from a buffer\n    in vec2 a_position;\n    \n    // Used to pass in the resolution of the canvas\n    uniform vec2 u_resolution;\n    \n    out vec4 v_color;\n\n    // all shaders have a main function\n    void main() {\n    \n      // convert the position from pixels to 0.0 to 1.0\n      vec2 zeroToOne = a_position / u_resolution;\n    \n      // convert from 0->1 to 0->2\n      vec2 zeroToTwo = zeroToOne * 2.0;\n    \n      // convert from 0->2 to -1->+1 (clipspace)\n      vec2 clipSpace = zeroToTwo - 1.0;\n    \n      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n\n      // Convert from clipspace to colorspace.\n      // Clipspace goes -1.0 to +1.0\n      // Colorspace goes from 0.0 to 1.0\n      v_color = vec4(1, gl_Position.xy, 1);\n    }\n    ":this._vertexShaderSource}set vertexShaderSource(t){this._vertexShaderSource=t,this.initializeWebGL()}get fragmentShaderSource(){return null===this._fragmentShaderSource?"#version 300 es\n  \n    precision mediump float;\n\n    in vec4 v_color;\n\n    uniform vec4 u_color;\n    \n    // we need to declare an output for the fragment shader\n    out vec4 outColor;\n    \n    void main() {\n      outColor = v_color;\n    }\n    ":this._fragmentShaderSource}set fragmentShaderSource(t){this._fragmentShaderSource=t,this.initializeWebGL()}constructor(){super(),this._R=null,this._p=null,this._r=null,this._reps=null,this._density=null,this._frozen=null,this._vertexShaderSource=null,this._fragmentShaderSource=null,this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="\n      <canvas data-canvas></canvas>\n      <style>\n      :host {\n        display: grid;\n      }\n      canvas {\n        width: 100%;\n        min-height: 100%;\n      }\n      ",this.initializeWebGL()}initializeWebGL(){const t=this.shadowRoot.querySelector("[data-canvas]");this.gl=t.getContext("webgl2"),this.program=this.getProgram(),this.gl.useProgram(this.program),this.positionAttributeLocation=this.gl.getAttribLocation(this.program,"a_position"),this.resolutionUniformLocation=this.gl.getUniformLocation(this.program,"u_resolution"),this.colorLocation=this.gl.getUniformLocation(this.program,"u_color"),this.timeLocation=this.gl.getUniformLocation(this.program,"u_time");const e=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,e)}createSpirograph(t,e,i,r,s,o){const n=this.getSpirographPoints(t,e,i,r,s),a=n.length/2;this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(n),this.gl.STATIC_DRAW),this.gl.uniform1f(this.timeLocation,o/2500);const h=this.gl.createVertexArray();this.gl.bindVertexArray(h),this.gl.uniform2f(this.resolutionUniformLocation,this.gl.canvas.width,this.gl.canvas.height),this.gl.enableVertexAttribArray(this.positionAttributeLocation);const l=this.gl.FLOAT;this.gl.vertexAttribPointer(this.positionAttributeLocation,2,l,!1,0,0),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.clearColor(0,0,0,0),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(h),this.gl.uniform4f(this.colorLocation,.1,.2,.1,1);const c=this.gl.LINE_STRIP,g=a;this.gl.drawArrays(c,0,g)}getProgram(){const t=this.createShader(this.gl,this.gl.VERTEX_SHADER,this.vertexShaderSource),e=this.createShader(this.gl,this.gl.FRAGMENT_SHADER,this.fragmentShaderSource);return this.createProgram(this.gl,t,e)}createShader(t,e,i){const r=t.createShader(e);t.shaderSource(r,i),t.compileShader(r);if(t.getShaderParameter(r,t.COMPILE_STATUS))return r;t.deleteShader(r)}createProgram(t,e,i){const r=t.createProgram();t.attachShader(r,e),t.attachShader(r,i),t.linkProgram(r);if(t.getProgramParameter(r,t.LINK_STATUS))return r;console.log(t.getProgramInfoLog(r)),t.deleteProgram(r)}resize(t){const e=window.devicePixelRatio||1,i=Math.floor(t.clientWidth*e),r=Math.floor(t.clientHeight*e);t.width===i&&t.height===r||(t.width=i,t.height=r)}connectedCallback(){this.resize(this.gl.canvas),this.createSpirographFromAttributes()}createSpirographFromAttributes(){this.createSpirograph(this.R,this.r,this.p,this.reps,this.density)}render(t){this.createSpirograph(this.R,this.r,this.p,this.reps,this.density,t)}attributeChangedCallback(t,e,i){this.frozen||this.createSpirographFromAttributes()}range(t,e,i){if(void 0===e&&(e=t,t=0),void 0===i&&(i=1),i>0&&t>=e||i<0&&t<=e)return[];var r=[];for(let s=t;i>0?s<e:s>e;s+=i)r.push(s);return r}disconnectedCallback(){}simplifyPoints(t,e,i,r,s){const o=s||[],n=t[e],a=t[i-1];let h=0,l=1;for(let r=e+1;r<i-1;++r){const e=this.distanceToSegmentSq(t[r],n,a);e>h&&(h=e,l=r)}return Math.sqrt(h)>r?(this.simplifyPoints(t,e,l+1,r,o),this.simplifyPoints(t,l,i,r,o)):o.push(n,a),o}distanceToSegmentSq(t,e,i){const r=this.distanceSq(e,i);if(0===r)return this.distanceSq(t,e);let s=((t[0]-e[0])*(i[0]-e[0])+(t[1]-e[1])*(i[1]-e[1]))/r;return s=Math.max(0,Math.min(1,s)),this.distanceSq(t,this.lerp(e,i,s))}lerp(t,e,i){return[t[0]+(e[0]-t[0])*i,t[1]+(e[1]-t[1])*i]}distanceSq(t,e){const i=t[0]-e[0],r=t[1]-e[1];return i*i+r*r}getSpirographPoints(t,e,i,r,s){const o=r=>(t+e)*Math.cos(r)+i*Math.cos((t+e)*(r/e)),n=r=>(t+e)*Math.sin(r)+i*Math.sin((t+e)*(r/e)),a=this.gl.canvas.width,h=this.gl.canvas.height,l=this.range(0,r,s).map((t=>[o(t)+a/2,n(t)+h/2]));return this.simplifyPoints(l,0,l.length,1).flat()}}customElements.define("mm-spirograph",Spirograph);