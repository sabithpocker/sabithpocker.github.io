class PointsRenderer{constructor(t,e,o={}){this.pointsCanvas=t,this.canvas=this.pointsCanvas,this.points=e,this.options={dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],hoverScale:1.5,zIndex:999,onClick:t=>console.log(t),...o},this.gl=this.pointsCanvas.getContext("webgl2"),this.setupGL(),this.setupInteraction()}setupGL(){const t=this.gl;if(!this.gl)return void console.error("WebGL2 not supported");const e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            layout(location = 1) in float a_isHovered;\n            \n            uniform vec2 u_resolution;\n            uniform float u_pointSize;\n            uniform float u_hoverScale;\n            \n            out float v_isHovered;\n            \n            void main() {\n                // Convert position from pixels to clip space\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n                \n                // Pass hover state to fragment shader\n                v_isHovered = a_isHovered;\n                \n                // Set point size with hover scaling\n                gl_PointSize = u_pointSize * (1.0 + (u_hoverScale - 1.0) * a_isHovered);\n            }\n        "),t.compileShader(e);const o=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(o,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_dotColor;\n            uniform vec4 u_hoverColor;\n            \n            in float v_isHovered;\n            out vec4 fragColor;\n            \n            void main() {\n                // Calculate distance from center of point\n                vec2 center = gl_PointCoord - vec2(0.5);\n                float dist = length(center);\n                \n                // Smooth circle with anti-aliasing\n                float alpha = smoothstep(0.5, 0.45, dist);\n                \n                // Mix between normal and hover colors\n                vec4 color = mix(u_dotColor, u_hoverColor, v_isHovered);\n                fragColor = vec4(color.rgb, color.a * alpha);\n            }\n        "),t.compileShader(o),this.program=t.createProgram(),t.attachShader(this.program,e),t.attachShader(this.program,o),t.linkProgram(this.program),this.uniformLocations={resolution:t.getUniformLocation(this.program,"u_resolution"),pointSize:t.getUniformLocation(this.program,"u_pointSize"),hoverScale:t.getUniformLocation(this.program,"u_hoverScale"),dotColor:t.getUniformLocation(this.program,"u_dotColor"),hoverColor:t.getUniformLocation(this.program,"u_hoverColor")},this.positionBuffer=t.createBuffer(),this.hoverBuffer=t.createBuffer(),this.vao=t.createVertexArray(),t.bindVertexArray(this.vao),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer);const i=new Float32Array(this.points.flatMap((t=>[t.x,t.y])));t.bufferData(t.ARRAY_BUFFER,i,t.STATIC_DRAW),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer);const n=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,n,t.DYNAMIC_DRAW),t.enableVertexAttribArray(1),t.vertexAttribPointer(1,1,t.FLOAT,!1,0,0),t.bindVertexArray(null)}setupInteraction(){this.canvas.style.pointerEvents="auto",this.hoveredPointIndex=-1,this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("click",this.handleClick.bind(this))}handleMouseMove(t){const e=this.canvas.getBoundingClientRect(),o=window.devicePixelRatio||1,i=(t.clientX-e.left)*o,n=(t.clientY-e.top)*o,r=this.hoveredPointIndex;this.hoveredPointIndex=this.findPointUnderCursor(i,n),r!==this.hoveredPointIndex&&(this.updateHoverStates(),this.render()),this.canvas.style.cursor=-1!==this.hoveredPointIndex?"pointer":"default"}handleClick(t){const e=this.canvas.getBoundingClientRect(),o=window.devicePixelRatio||1,i=(t.clientX-e.left)*o,n=(t.clientY-e.top)*o,r=this.findPointUnderCursor(i,n);-1!==r&&this.options.onClick&&this.options.onClick(this.points[r]),console.log(this.points[r],i,n)}findPointUnderCursor(t,e){const o=window.devicePixelRatio||1,i=2*this.options.dotRadius*o;return this.points.findIndex((n=>{const r=n.x-t*o,s=n.y-e*o;return r*r+s*s<=i*i}))}updateHoverStates(){const t=this.gl,e=new Float32Array(this.points.length);-1!==this.hoveredPointIndex&&(e[this.hoveredPointIndex]=1),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}render(){const t=this.gl;t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.useProgram(this.program),t.bindVertexArray(this.vao);const e=window.devicePixelRatio||1;t.uniform2f(this.uniformLocations.resolution,this.canvas.width*e,this.canvas.height*e),t.uniform1f(this.uniformLocations.pointSize,2*this.options.dotRadius*e),t.uniform1f(this.uniformLocations.hoverScale,this.options.hoverScale),t.uniform4fv(this.uniformLocations.dotColor,this.options.dotColor),t.uniform4fv(this.uniformLocations.hoverColor,this.options.hoverColor),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.drawArrays(t.POINTS,0,this.points.length),t.bindVertexArray(null)}cleanup(){const t=this.gl;this.canvas.removeEventListener("mousemove",this.handleMouseMove),this.canvas.removeEventListener("click",this.handleClick),t.deleteBuffer(this.positionBuffer),t.deleteBuffer(this.hoverBuffer),t.deleteProgram(this.program),t.deleteVertexArray(this.vao)}}class AlhambraTiled extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="\n          <canvas data-canvas></canvas>\n          <canvas data-canvas-points></canvas>\n          <style>\n          :host {\n            display: grid;\n            position: relative;\n          }\n          canvas {\n            width: 100%;\n            min-height: 100%;\n            position: absolute;\n            left: 0;\n            top: 0;\n          }\n          </style>",this.canvas=this.shadowRoot.querySelector("canvas"),this.pointsCanvas=this.shadowRoot.querySelector("canvas[data-canvas-points]"),this.gl=this.canvas.getContext("webgl2"),this.gl?(this.updatePointsCanvasSize(this.pointsCanvas),this.pointsRenderer=null,this.points=null,this.textureCanvas=document.createElement("canvas"),this.textureCanvas.width=2048,this.textureCanvas.height=2048,this.textureCtx=this.textureCanvas.getContext("2d"),this.initializeTexture(),this.initializeWebGL(),this.updateCanvasSize(this.canvas),this.render()):console.error("WebGL2 not supported")}generateTilePattern(){const t=this.textureCtx,e=this.textureCanvas.width,o=this.textureCanvas.height,i=e/2,n=o/2;let r=new Set;const s=(t,i)=>{if(t>=0&&t<=e&&i>=0&&i<=o){const e=Math.round(1e3*t)/1e3,o=Math.round(1e3*i)/1e3;r.add(`${e},${o}`)}},a=(t,e,o,i,n,r,s,a)=>{const h=(t-o)*(r-a)-(e-i)*(n-s);if(0===h)return null;const c=((t-n)*(r-a)-(e-r)*(n-s))/h,l=-((t-o)*(e-r)-(e-i)*(t-n))/h;if(c>=0&&c<=1&&l>=0&&l<=1){return[t+c*(o-t),e+c*(i-e)]}return null};t.fillStyle="#1a1324",t.fillRect(0,0,e,o),t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1;const h=Math.tan(22.5*Math.PI/180),c=(Math.tan(67.5*Math.PI/180),[[[0,0],[e,o]],[[e,0],[0,o]],[[i,0],[i,o]],[[0,n],[e,n]],[[0,n-i*h],[e,n+i*h]],[[0,n+i*h],[e,n-i*h]],[[i-n*h,0],[i+n*h,o]],[[i+n*h,0],[i-n*h,o]]]);t.beginPath(),c.forEach((([[e,o],[i,n]])=>{t.moveTo(e,o),t.lineTo(i,n)})),t.stroke(),t.beginPath(),t.rect(0,0,e,o),t.stroke();const l=Math.min(e,o)/2;t.beginPath(),t.arc(i,n,l,0,2*Math.PI),t.stroke();const d=e*Math.sqrt(2)/8;t.beginPath(),t.arc(i,n,d,0,2*Math.PI),t.stroke();const u=d*Math.sqrt(2)/2,v=[[[i-u,0],[i-u,o]],[[i+u,0],[i+u,o]],[[0,n-u],[e,n-u]],[[0,n+u],[e,n+u]]];t.beginPath(),v.forEach((([[e,o],[i,n]])=>{t.moveTo(e,o),t.lineTo(i,n)})),t.stroke(),c.push(...v),t.save(),t.translate(i,n),t.rotate(Math.PI/4);const f=[[[-u,-e],[-u,e]],[[u,-e],[u,e]],[[-e,-u],[e,-u]],[[-e,u],[e,u]]];t.beginPath(),f.forEach((([[e,o],[i,n]])=>{t.moveTo(e,o),t.lineTo(i,n)})),t.stroke(),t.restore();const p=Math.cos(Math.PI/4),m=Math.sin(Math.PI/4),g=f.map((([[t,e],[o,r]])=>[[i+(t*p-e*m),n+(t*m+e*p)],[i+(o*p-r*m),n+(o*m+r*p)]]));c.push(...g);const R=e*Math.sqrt(2)/2-l,x=[[i,n,l],[i,n,d],[0,0,R],[e,0,R],[e,o,R],[0,o,R]],_=[[0,Math.PI/2],[Math.PI/2,Math.PI],[Math.PI,3*Math.PI/2],[3*Math.PI/2,2*Math.PI]],A=[[0,0],[e,0],[e,o],[0,o]];_.forEach(((e,o)=>{t.beginPath(),t.arc(A[o][0],A[o][1],R,...e),t.stroke()}));const C=R/Math.sqrt(2),P=[{mid1:[0,n],mid2:[i,0],intersect:[C,C]},{mid1:[e,n],mid2:[i,0],intersect:[e-C,C]},{mid1:[e,n],mid2:[i,o],intersect:[e-C,o-C]},{mid1:[0,n],mid2:[i,o],intersect:[C,o-C]}];function S(t,e,o,i,n,r){const s=o-t,a=i-e,h=a/s;let c,l;return s>0?(c=n,l=e+h*(n-t)):(c=0,l=e+h*(0-t)),(l<0||l>r)&&(l=a>0?r:0,c=t+(l-e)/h),[c,l]}t.beginPath(),P.forEach((i=>{const[n,r]=S(i.mid1[0],i.mid1[1],i.intersect[0],i.intersect[1],e,o);t.moveTo(i.mid1[0],i.mid1[1]),t.lineTo(n,r),c.push([[i.mid1[0],i.mid1[1]],[n,r]]);const[s,a]=S(i.mid2[0],i.mid2[1],i.intersect[0],i.intersect[1],e,o);t.moveTo(i.mid2[0],i.mid2[1]),t.lineTo(s,a),c.push([[i.mid2[0],i.mid2[1]],[s,a]])})),t.stroke();for(let t=0;t<c.length;t++)for(let e=t+1;e<c.length;e++){const o=a(c[t][0][0],c[t][0][1],c[t][1][0],c[t][1][1],c[e][0][0],c[e][0][1],c[e][1][0],c[e][1][1]);o&&s(o[0],o[1])}x.forEach((t=>{c.forEach((e=>{((t,e,o,i,n,r,s)=>{const a=r-i,h=s-n,c=a*a+h*h,l=2*(a*(i-t)+h*(n-e)),d=l*l-4*c*(t*t+e*e+i*i+n*n-2*(t*i+e*n)-o*o);if(d<0)return[];if(0===d){const t=-l/(2*c);return t>=0&&t<=1?[[i+t*a,n+t*h]]:[]}const u=(-l+Math.sqrt(d))/(2*c),v=(-l-Math.sqrt(d))/(2*c),f=[];return u>=0&&u<=1&&f.push([i+u*a,n+u*h]),v>=0&&v<=1&&f.push([i+v*a,n+v*h]),f})(t[0],t[1],t[2],e[0][0],e[0][1],e[1][0],e[1][1]).forEach((t=>s(t[0],t[1])))}))})),this.points=Array.from(r).map((t=>{const[e,o]=t.split(",").map(Number);return{x:e,y:o}})),console.log(this.points)}createPointsRenderer(t){this.pointsRenderer=new PointsRenderer(this.pointsCanvas,t,{dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],hoverScale:1.5}),this.pointsRenderer.render()}initializeTexture(){this.generateTilePattern();const t=this.gl;this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.textureCanvas),this.createPointsRenderer(this.points)}get vertexShaderSource(){return"#version 300 es\n        in vec4 a_position;\n        in vec2 a_texCoord;\n        uniform vec2 u_resolution;\n        out vec2 v_texCoord;\n        \n        void main() {\n            vec2 zeroToOne = a_position.xy / u_resolution;\n            vec2 clipSpace = (zeroToOne * 2.0 - 1.0) * vec2(1, -1);\n            gl_Position = vec4(clipSpace, 0, 1);\n            v_texCoord = a_texCoord;\n        }"}get fragmentShaderSource(){return"#version 300 es\n        precision highp float;\n        \n        in vec2 v_texCoord;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        out vec4 outColor;\n        \n        void main() {\n            vec2 repeat = u_resolution / 1024.0;  // 512 is texture size\n            vec2 texCoord = fract(v_texCoord * repeat);\n            outColor = texture(u_texture, texCoord);\n        }"}createShader(t,e,o){const i=t.createShader(e);return t.shaderSource(i,o),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS)?i:(console.error(t.getShaderInfoLog(i)),t.deleteShader(i),null)}createProgram(t,e,o){const i=t.createProgram();return t.attachShader(i,e),t.attachShader(i,o),t.linkProgram(i),t.getProgramParameter(i,t.LINK_STATUS)?i:(console.error(t.getProgramInfoLog(i)),t.deleteProgram(i),null)}initializeWebGL(){const t=this.gl,e=this.createShader(t,t.VERTEX_SHADER,this.vertexShaderSource),o=this.createShader(t,t.FRAGMENT_SHADER,this.fragmentShaderSource);this.program=this.createProgram(t,e,o),this.positionLocation=t.getAttribLocation(this.program,"a_position"),this.texCoordLocation=t.getAttribLocation(this.program,"a_texCoord"),this.resolutionLocation=t.getUniformLocation(this.program,"u_resolution"),this.positionBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),t.STATIC_DRAW)}updateCanvasSize(t){const e=window.devicePixelRatio||1,o=this.clientWidth||300,i=this.clientHeight||300;t.width=o*e,t.height=i*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}updatePointsCanvasSize(t){const e=window.devicePixelRatio||1,o=512;t.style.width="512px",t.style.height="512px",t.style.minHeight="unset",t.width=o*e,t.height=o*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}render(){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,this.canvas.width,0,0,this.canvas.height,0,this.canvas.height,this.canvas.width,0,this.canvas.width,this.canvas.height]),t.STATIC_DRAW),t.useProgram(this.program),t.enableVertexAttribArray(this.positionLocation),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.vertexAttribPointer(this.positionLocation,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.texCoordLocation),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.vertexAttribPointer(this.texCoordLocation,2,t.FLOAT,!1,0,0),t.uniform2f(this.resolutionLocation,t.canvas.width,t.canvas.height),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawArrays(t.TRIANGLES,0,6)}connectedCallback(){new ResizeObserver((()=>{this.updateCanvasSize(this.canvas),this.updatePointsCanvasSize(this.pointsCanvas),this.render()})).observe(this)}disconnectedCallback(){this.resizeObserver&&this.resizeObserver.disconnect()}}customElements.define("mm-alhambra",AlhambraTiled);