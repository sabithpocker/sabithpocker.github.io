const defaultPattern="point1,point2\n5,80\n54,80\n15,54\n15,39\n39,77\n0,77\n0,13\n1,13\n1,74\n53,74\n16,53\n16,40\n40,75\n4,75\n6,67\n33,67\n9,33\n9,47\n47,66\n3,66\n3,19\n2,19\n2,69\n34,69\n10,34\n10,48\n48,72\n7,72\n7,20\n31,61\n31,64\n15,64\n24,54\n24,48\n48,63\n32,63\n32,62\n16,62\n16,59\n25,59\n25,57\n9,57\n9,61\n15,58\n26,58\n26,60\n10,60";class PointsRenderer{constructor(t,e,i={}){this.pointsCanvas=t,this.canvas=this.pointsCanvas,this.points=e,this.isDrawingEnabled=!1,this.selectedPoints=[],this.lineConnections=new Set,this.options={dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],selectedColor:[.4,1,.4,.9],lineColor:[0,1,0,.8],lineWidth:2,hoverScale:1.5,zIndex:999,onLineAdded:null,onExportCSV:null,onImportCSV:null,onDrawingStateChanged:null,...i},this.gl=this.pointsCanvas.getContext("webgl2",{antialias:!0,alpha:!0}),this.setupGL(),this.setupInteraction(),this.importFromCSV(defaultPattern)}setDrawingMode(t){this.isDrawingEnabled=t,t||(this.selectedPoints=[],this.updateSelectedStates(),this.render()),this.updateCursor(),this.options.onDrawingStateChanged&&this.options.onDrawingStateChanged(t)}updateCursor(){this.isDrawingEnabled?-1!==this.hoveredPointIndex?this.canvas.style.cursor='url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23ffffff" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="8" stroke-dasharray="2"/></svg>\') 12 12, crosshair':this.canvas.style.cursor="crosshair":this.canvas.style.cursor=-1!==this.hoveredPointIndex?"pointer":"default"}exportToCSV(){return"point1,point2\n"+Array.from(this.lineConnections).map((t=>{const[e,i]=t.split(",");return`${e},${i}`})).join("\n")}importFromCSV(t){this.lineConnections.clear(),this.selectedPoints=[];t.split("\n").slice(1).forEach((t=>{if(t.trim()){const[e,i]=t.split(",").map(Number);if(!isNaN(e)&&!isNaN(i)){this.lineConnections.add(`${e},${i}`),this.selectedPoints.includes(e)||this.selectedPoints.push(e),this.selectedPoints.includes(i)||this.selectedPoints.push(i);const t=this.points[e],n=this.points[i];this.options.onLineAdded&&this.options.onLineAdded(t,n)}}})),this.updateSelectedStates(),this.render()}setupGL(){const t=this.gl;if(!this.gl)return void console.error("WebGL2 not supported");const e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            layout(location = 1) in float a_isHovered;\n            layout(location = 2) in float a_isSelected;\n            \n            uniform vec2 u_resolution;\n            uniform float u_pointSize;\n            uniform float u_hoverScale;\n            \n            out float v_isHovered;\n            out float v_isSelected;\n            \n            void main() {\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n                \n                v_isHovered = a_isHovered;\n                v_isSelected = a_isSelected;\n                \n                gl_PointSize = u_pointSize * (1.0 + (u_hoverScale - 1.0) * a_isHovered);\n            }\n        "),t.compileShader(e);const i=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(i,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_dotColor;\n            uniform vec4 u_hoverColor;\n            uniform vec4 u_selectedColor;\n            \n            in float v_isHovered;\n            in float v_isSelected;\n            out vec4 fragColor;\n            \n            void main() {\n                vec2 center = gl_PointCoord - vec2(0.5);\n                float dist = length(center);\n                float alpha = smoothstep(0.5, 0.45, dist);\n                \n                vec4 color = mix(\n                    mix(u_dotColor, u_selectedColor, v_isSelected),\n                    u_hoverColor,\n                    v_isHovered\n                );\n                fragColor = vec4(color.rgb, color.a * alpha);\n            }\n        "),t.compileShader(i);const n=t.createShader(t.VERTEX_SHADER);t.shaderSource(n,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            \n            uniform vec2 u_resolution;\n            \n            void main() {\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n            }\n        "),t.compileShader(n);const o=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(o,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_lineColor;\n            out vec4 fragColor;\n            \n            void main() {\n                fragColor = u_lineColor;\n            }\n        "),t.compileShader(o),this.pointProgram=t.createProgram(),t.attachShader(this.pointProgram,e),t.attachShader(this.pointProgram,i),t.linkProgram(this.pointProgram),this.lineProgram=t.createProgram(),t.attachShader(this.lineProgram,n),t.attachShader(this.lineProgram,o),t.linkProgram(this.lineProgram),this.pointUniformLocations={resolution:t.getUniformLocation(this.pointProgram,"u_resolution"),pointSize:t.getUniformLocation(this.pointProgram,"u_pointSize"),hoverScale:t.getUniformLocation(this.pointProgram,"u_hoverScale"),dotColor:t.getUniformLocation(this.pointProgram,"u_dotColor"),hoverColor:t.getUniformLocation(this.pointProgram,"u_hoverColor"),selectedColor:t.getUniformLocation(this.pointProgram,"u_selectedColor")},this.lineUniformLocations={resolution:t.getUniformLocation(this.lineProgram,"u_resolution"),lineColor:t.getUniformLocation(this.lineProgram,"u_lineColor")},this.positionBuffer=t.createBuffer(),this.hoverBuffer=t.createBuffer(),this.selectedBuffer=t.createBuffer(),this.lineBuffer=t.createBuffer(),this.pointVAO=t.createVertexArray(),t.bindVertexArray(this.pointVAO),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer);const s=new Float32Array(this.points.flatMap((t=>[t.x,t.y])));t.bufferData(t.ARRAY_BUFFER,s,t.STATIC_DRAW),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer);const r=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,r,t.DYNAMIC_DRAW),t.enableVertexAttribArray(1),t.vertexAttribPointer(1,1,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.selectedBuffer);const a=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,a,t.DYNAMIC_DRAW),t.enableVertexAttribArray(2),t.vertexAttribPointer(2,1,t.FLOAT,!1,0,0),this.lineVAO=t.createVertexArray(),t.bindVertexArray(this.lineVAO),t.bindBuffer(t.ARRAY_BUFFER,this.lineBuffer),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindVertexArray(null)}updateSelectedStates(){const t=this.gl,e=new Float32Array(this.points.length);this.selectedPoints.forEach((t=>{e[t]=1})),t.bindBuffer(t.ARRAY_BUFFER,this.selectedBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}updateLineBuffer(){const t=this.gl,e=window.devicePixelRatio||1;if(this.selectedPoints.length<2)return;const i=[];for(let t=1;t<this.selectedPoints.length;t++){const n=this.points[this.selectedPoints[t-1]],o=this.points[this.selectedPoints[t]];i.push(n.x/e,n.y/e,o.x/e,o.y/e)}t.bindBuffer(t.ARRAY_BUFFER,this.lineBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array(i),t.DYNAMIC_DRAW)}handleClick(t){if(!this.isDrawingEnabled)return;const e=this.canvas.getBoundingClientRect(),i=window.devicePixelRatio||1,n=(t.clientX-e.left)*i,o=(t.clientY-e.top)*i,s=this.findPointUnderCursor(n,o);if(-1!==s){const t=this.points[s];if(this.selectedPoints.length>0){const e=this.selectedPoints[this.selectedPoints.length-1],i=[e,s].sort(((t,e)=>t-e)).join(",");if(this.lineConnections.add(i),this.options.onLineAdded){const i=this.points[e];this.options.onLineAdded(i,t)}}this.selectedPoints.push(s),this.updateSelectedStates(),this.render()}}render(){const t=this.gl;t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this.selectedPoints.length>=2&&(t.useProgram(this.lineProgram),t.bindVertexArray(this.lineVAO),t.uniform2f(this.lineUniformLocations.resolution,this.canvas.width,this.canvas.height),t.uniform4fv(this.lineUniformLocations.lineColor,this.options.lineColor),t.lineWidth(this.options.lineWidth),t.drawArrays(t.LINES,0,2*(this.selectedPoints.length-1))),t.useProgram(this.pointProgram),t.bindVertexArray(this.pointVAO);const e=window.devicePixelRatio||1;t.uniform2f(this.pointUniformLocations.resolution,this.canvas.width*e,this.canvas.height*e),t.uniform1f(this.pointUniformLocations.pointSize,2*this.options.dotRadius*e),t.uniform1f(this.pointUniformLocations.hoverScale,this.options.hoverScale),t.uniform4fv(this.pointUniformLocations.dotColor,this.options.dotColor),t.uniform4fv(this.pointUniformLocations.hoverColor,this.options.hoverColor),t.uniform4fv(this.pointUniformLocations.selectedColor,this.options.selectedColor),t.drawArrays(t.POINTS,0,this.points.length),t.bindVertexArray(null)}setupInteraction(){this.canvas.style.pointerEvents="auto",this.hoveredPointIndex=-1,this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("click",this.handleClick.bind(this))}handleMouseMove(t){const e=this.canvas.getBoundingClientRect(),i=window.devicePixelRatio||1,n=(t.clientX-e.left)*i,o=(t.clientY-e.top)*i,s=this.hoveredPointIndex;this.hoveredPointIndex=this.findPointUnderCursor(n,o),s!==this.hoveredPointIndex&&(this.updateHoverStates(),this.updateCursor(),this.render())}findPointUnderCursor(t,e){const i=window.devicePixelRatio||1,n=2*this.options.dotRadius*i;return this.points.findIndex((o=>{const s=o.x-t*i,r=o.y-e*i;return s*s+r*r<=n*n}))}updateHoverStates(){const t=this.gl,e=new Float32Array(this.points.length);-1!==this.hoveredPointIndex&&(e[this.hoveredPointIndex]=1),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}cleanup(){const t=this.gl;this.canvas.removeEventListener("mousemove",this.handleMouseMove),this.canvas.removeEventListener("click",this.handleClick),t.deleteBuffer(this.positionBuffer),t.deleteBuffer(this.hoverBuffer),t.deleteProgram(this.program),t.deleteVertexArray(this.vao)}}class AlhambraTiled extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML='<div class="controls">\n            <div class="control-group">\n              <label>\n                Tile Size:\n                <input type="range" min="128" max="1024" value="128" step="64" data-tile-size>\n                <span class="tile-size-value">512px</span>\n              </label>\n              <label>\n                Stroke Width:\n                <input type="range" min="1" max="20" value="20" step="1" data-stroke-width>\n                <span class="stroke-width-value">2px</span>\n              </label>\n            </div>\n            <div class="control-group">\n              <label>\n                Line Color:\n                <input type="color" value="#ffffff" data-line-color>\n                <input type="range" min="0" max="100" value="30" step="5" data-line-opacity>\n                <span class="line-opacity-value">30%</span>\n              </label>\n              <label>\n                Background:\n                <input type="color" value="#1a1324" data-bg-color>\n              </label>\n            </div>\n          </div>\n          <canvas data-canvas></canvas>\n          <canvas data-canvas-points></canvas>\n               <style>\n          :host {\n            display: grid;\n            position: relative;\n          }\n          .controls {\n            position: absolute;\n            bottom: 10px;\n            left: 250px;\n            z-index: 1000;\n            background: rgba(0,0,0,0.7);\n            padding: 10px;\n            border-radius: 4px;\n            color: white;\n            display: flex;\n            flex-direction: column;\n            gap: 10px;\n          }\n          .control-group {\n            display: flex;\n            gap: 20px;\n          }\n          .controls label {\n            display: flex;\n            align-items: center;\n            gap: 8px;\n          }\n          input[type="color"] {\n            width: 40px;\n            height: 24px;\n            padding: 0;\n            border: none;\n            border-radius: 4px;\n          }\n          canvas {\n            width: 100%;\n            min-height: 100%;\n            position: absolute;\n            left: 0;\n            top: 0;\n          }\n          </style>',this.lineColorInput=this.shadowRoot.querySelector("[data-line-color]"),this.lineOpacityInput=this.shadowRoot.querySelector("[data-line-opacity]"),this.lineOpacityValue=this.shadowRoot.querySelector(".line-opacity-value"),this.bgColorInput=this.shadowRoot.querySelector("[data-bg-color]"),this.lineColor=this.lineColorInput.value,this.lineOpacity=parseInt(this.lineOpacityInput.value)/100,this.backgroundColor=this.bgColorInput.value,this.setupColorControls(),this.strokeWidthInput=this.shadowRoot.querySelector("[data-stroke-width]"),this.strokeWidthValue=this.shadowRoot.querySelector(".stroke-width-value"),this.strokeWidth=parseFloat(this.strokeWidthInput.value),this.setupStrokeWidthControl(),this.canvas=this.shadowRoot.querySelector("canvas"),this.pointsCanvas=this.shadowRoot.querySelector("canvas[data-canvas-points]"),this.tileSizeInput=this.shadowRoot.querySelector("[data-tile-size]"),this.tileSizeValue=this.shadowRoot.querySelector(".tile-size-value"),this.tileSize=parseInt(this.tileSizeInput.value),this.selectedLines=new Set,this.setupTileSizeControl(),this.gl=this.canvas.getContext("webgl2",{antialias:!0,alpha:!0}),this.gl?(this.updatePointsCanvasSize(this.pointsCanvas),this.pointsRenderer=null,this.points=null,this.textureCanvas=document.createElement("canvas"),this.textureCanvas.width=2048,this.textureCanvas.height=2048,this.textureCtx=this.textureCanvas.getContext("2d",{antialias:!0,alpha:!0}),this.initializeTexture(),this.initializeWebGL(),this.updateCanvasSize(this.canvas),this.render(),this.setupExportImport(),this.setupDrawControls()):console.error("WebGL2 not supported")}setupColorControls(){this.lineColorInput.addEventListener("input",(t=>{this.lineColor=t.target.value,this.resetPattern(),this.pointsRenderer&&(this.pointsRenderer.importFromCSV(defaultPattern),this.pointsRenderer.render())})),this.lineOpacityInput.addEventListener("input",(t=>{this.lineOpacity=parseInt(t.target.value)/100,this.lineOpacityValue.textContent=`${t.target.value}%`,this.resetPattern(),this.pointsRenderer&&(this.pointsRenderer.importFromCSV(defaultPattern),this.pointsRenderer.render())})),this.bgColorInput.addEventListener("input",(t=>{this.backgroundColor=t.target.value}))}hexToRgba(t,e=1){return`rgba(${parseInt(t.slice(1,3),16)}, ${parseInt(t.slice(3,5),16)}, ${parseInt(t.slice(5,7),16)}, ${e})`}setupStrokeWidthControl(){this.strokeWidthInput.addEventListener("input",(t=>{this.strokeWidth=parseFloat(t.target.value),this.strokeWidthValue.textContent=`${this.strokeWidth}px`,this.resetPattern(),this.pointsRenderer&&(this.pointsRenderer.importFromCSV(defaultPattern),this.pointsRenderer.options.lineWidth=this.strokeWidth,this.pointsRenderer.render())}))}setupDrawControls(){const t=document.createElement("div");t.style.cssText="\n            position: absolute;\n            bottom: 10px;\n            left: 200px;\n            display: flex;\n            gap: 10px;\n            z-index: 1000;\n        ";const e=document.createElement("button");e.textContent="Start Drawing",e.onclick=()=>this.setDrawingMode(!0);const i=document.createElement("button");i.textContent="Stop Drawing",i.onclick=()=>this.setDrawingMode(!1),i.style.display="none",this.drawButtons={start:e,stop:i},t.appendChild(e),t.appendChild(i),this.shadowRoot.appendChild(t)}setupTileSizeControl(){this.tileSizeInput.addEventListener("input",(t=>{this.tileSize=parseInt(t.target.value),this.tileSizeValue.textContent=`${this.tileSize}px`,this.updatePointsCanvasSize(this.pointsCanvas),this.render()}))}setDrawingMode(t){this.pointsRenderer&&(this.pointsRenderer.setDrawingMode(t),this.drawButtons.start.style.display=t?"none":"block",this.drawButtons.stop.style.display=t?"block":"none")}setupExportImport(){const t=document.createElement("div");t.style.cssText="\n            position: absolute;\n            bottom: 10px;\n            right: 10px;\n            display: flex;\n            gap: 10px;\n            z-index: 1000;\n        ";const e=document.createElement("button");e.textContent="Export CSV",e.onclick=()=>this.exportPattern();const i=document.createElement("button");i.textContent="Import CSV",i.onclick=()=>this.importPattern();const n=document.createElement("input");n.type="file",n.accept=".csv",n.style.display="none",n.onchange=t=>this.handleFileImport(t),t.appendChild(e),t.appendChild(i),t.appendChild(n),this.shadowRoot.appendChild(t),this.fileInput=n}addLineToPattern(t,e){const i=this.textureCtx;i.beginPath(),i.strokeStyle=this.hexToRgba(this.lineColor,.8),i.lineWidth=this.strokeWidth,i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke();const n=this.gl;n.bindTexture(n.TEXTURE_2D,this.texture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,this.textureCanvas),this.render()}generateTilePattern(){const t=this.textureCtx,e=this.textureCanvas.width,i=this.textureCanvas.height;t.fillStyle=this.backgroundColor,t.fillRect(0,0,e,i),t.strokeStyle=this.hexToRgba(this.lineColor,this.lineOpacity),t.lineWidth=this.strokeWidth,t.strokeStyle="rgba(255, 255, 255, 0.3)";const n=e/2,o=i/2;let s=new Set;const r=(t,n)=>{{const o=Math.max(0,Math.min(e,t)),r=Math.max(0,Math.min(i,n)),a=Math.round(1e3*o)/1e3,h=Math.round(1e3*r)/1e3;s.add(`${a},${h}`)}},a=(t,e,i,n,o,s,r,a)=>{const h=(t-i)*(s-a)-(e-n)*(o-r);if(0===h)return null;const l=((t-o)*(s-a)-(e-s)*(o-r))/h,d=-((t-i)*(e-s)-(e-n)*(t-o))/h;if(l>=0&&l<=1&&d>=0&&d<=1){return[t+l*(i-t),e+l*(n-e)]}return null};t.fillStyle="#1a1324",t.fillRect(0,0,e,i),t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1;const h=Math.tan(22.5*Math.PI/180),l=(Math.tan(67.5*Math.PI/180),[[[0,0],[e,i]],[[e,0],[0,i]],[[n,0],[n,i]],[[0,o],[e,o]],[[0,o-n*h],[e,o+n*h]],[[0,o+n*h],[e,o-n*h]],[[n-o*h,0],[n+o*h,i]],[[n+o*h,0],[n-o*h,i]]]);t.beginPath(),l.forEach((([[e,i],[n,o]])=>{t.moveTo(e,i),t.lineTo(n,o)})),t.stroke(),t.beginPath(),t.rect(0,0,e,i),t.stroke();const d=Math.min(e,i)/2;t.beginPath(),t.arc(n,o,d,0,2*Math.PI),t.stroke();const c=e*Math.sqrt(2)/8;t.beginPath(),t.arc(n,o,c,0,2*Math.PI),t.stroke();const u=c*Math.sqrt(2)/2,p=[[[n-u,0],[n-u,i]],[[n+u,0],[n+u,i]],[[0,o-u],[e,o-u]],[[0,o+u],[e,o+u]]];t.beginPath(),p.forEach((([[e,i],[n,o]])=>{t.moveTo(e,i),t.lineTo(n,o)})),t.stroke(),l.push(...p),t.save(),t.translate(n,o),t.rotate(Math.PI/4);const v=[[[-u,-e],[-u,e]],[[u,-e],[u,e]],[[-e,-u],[e,-u]],[[-e,u],[e,u]]];t.beginPath(),v.forEach((([[e,i],[n,o]])=>{t.moveTo(e,i),t.lineTo(n,o)})),t.stroke(),t.restore();const f=Math.cos(Math.PI/4),m=Math.sin(Math.PI/4),g=v.map((([[t,e],[i,s]])=>[[n+(t*f-e*m),o+(t*m+e*f)],[n+(i*f-s*m),o+(i*m+s*f)]]));l.push(...g);const x=e*Math.sqrt(2)/2-d,C=[[n,o,d],[n,o,c],[0,0,x],[e,0,x],[e,i,x],[0,i,x]];r(x,0),r(0,x),r(e-x,0),r(e,x),r(e-x,i),r(e,i-x),r(x,i),r(0,i-x);const R=[[0,Math.PI/2],[Math.PI/2,Math.PI],[Math.PI,3*Math.PI/2],[3*Math.PI/2,2*Math.PI]],S=[[0,0],[e,0],[e,i],[0,i]];R.forEach(((e,i)=>{t.beginPath(),t.arc(S[i][0],S[i][1],x,...e),t.stroke()}));const P=x/Math.sqrt(2),A=[{mid1:[0,o],mid2:[n,0],intersect:[P,P]},{mid1:[e,o],mid2:[n,0],intersect:[e-P,P]},{mid1:[e,o],mid2:[n,i],intersect:[e-P,i-P]},{mid1:[0,o],mid2:[n,i],intersect:[P,i-P]}];function b(t,e,i,n,o,s){const r=i-t,a=n-e,h=a/r;let l,d;return r>0?(l=o,d=e+h*(o-t)):(l=0,d=e+h*(0-t)),(d<0||d>s)&&(d=a>0?s:0,l=t+(d-e)/h),[l,d]}t.beginPath(),A.forEach((n=>{const[o,s]=b(n.mid1[0],n.mid1[1],n.intersect[0],n.intersect[1],e,i);t.moveTo(n.mid1[0],n.mid1[1]),t.lineTo(o,s),l.push([[n.mid1[0],n.mid1[1]],[o,s]]);const[r,a]=b(n.mid2[0],n.mid2[1],n.intersect[0],n.intersect[1],e,i);t.moveTo(n.mid2[0],n.mid2[1]),t.lineTo(r,a),l.push([[n.mid2[0],n.mid2[1]],[r,a]])})),t.stroke();for(let t=0;t<l.length;t++)for(let e=t+1;e<l.length;e++){const i=a(l[t][0][0],l[t][0][1],l[t][1][0],l[t][1][1],l[e][0][0],l[e][0][1],l[e][1][0],l[e][1][1]);i&&r(i[0],i[1])}C.forEach((t=>{l.forEach((e=>{((t,e,i,n,o,s,r)=>{const a=s-n,h=r-o,l=a*a+h*h,d=2*(a*(n-t)+h*(o-e)),c=d*d-4*l*(t*t+e*e+n*n+o*o-2*(t*n+e*o)-i*i);if(c<0)return[];if(0===c){const t=-d/(2*l);return t>=0&&t<=1?[[n+t*a,o+t*h]]:[]}const u=(-d+Math.sqrt(c))/(2*l),p=(-d-Math.sqrt(c))/(2*l),v=[];return u>=0&&u<=1&&v.push([n+u*a,o+u*h]),p>=0&&p<=1&&v.push([n+p*a,o+p*h]),v})(t[0],t[1],t[2],e[0][0],e[0][1],e[1][0],e[1][1]).forEach((t=>r(t[0],t[1])))}))})),this.points=Array.from(s).map((t=>{const[e,i]=t.split(",").map(Number);return{x:e,y:i}}))}exportPattern(){if(this.pointsRenderer){const t=this.pointsRenderer.exportToCSV(),e=new Blob([t],{type:"text/csv"}),i=window.URL.createObjectURL(e),n=document.createElement("a");n.href=i,n.download="alhambra_pattern.csv",n.click(),window.URL.revokeObjectURL(i)}}importPattern(){this.fileInput.click()}handleFileImport(t){const e=t.target.files[0];if(e){const t=new FileReader;t.onload=t=>{const e=t.target.result;this.resetPattern(),this.pointsRenderer.importFromCSV(e)},t.readAsText(e)}}resetPattern(){this.textureCtx.clearRect(0,0,this.textureCanvas.width,this.textureCanvas.height),this.generateTilePattern();const t=this.gl;t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.textureCanvas),this.render()}createPointsRenderer(t){const e=[parseInt(this.lineColor.slice(1,3),16)/255,parseInt(this.lineColor.slice(3,5),16)/255,parseInt(this.lineColor.slice(5,7),16)/255];this.pointsRenderer=new PointsRenderer(this.pointsCanvas,t,{dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],hoverScale:1.5,lineWidth:this.strokeWidth,lineColor:[...e,.8],onLineAdded:(t,e)=>{this.addLineToPattern(t,e)},onDrawingStateChanged:t=>{this.drawButtons.start.style.display=t?"none":"block",this.drawButtons.stop.style.display=t?"block":"none"}}),this.pointsRenderer.render()}initializeTexture(){this.generateTilePattern();const t=this.gl;this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.textureCanvas),this.createPointsRenderer(this.points)}get vertexShaderSource(){return"#version 300 es\n        in vec4 a_position;\n        in vec2 a_texCoord;\n        uniform vec2 u_resolution;\n        out vec2 v_texCoord;\n        \n        void main() {\n            vec2 zeroToOne = a_position.xy / u_resolution;\n            vec2 clipSpace = (zeroToOne * 2.0 - 1.0) * vec2(1, -1);\n            gl_Position = vec4(clipSpace, 0, 1);\n            v_texCoord = a_texCoord;\n        }"}get fragmentShaderSource(){return"#version 300 es\n        precision highp float;\n        \n        in vec2 v_texCoord;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_tileSize;  // Added uniform for tile size\n        out vec4 outColor;\n        \n        void main() {\n            vec2 repeat = u_resolution / u_tileSize;  // Use dynamic tile size\n            vec2 texCoord = fract(v_texCoord * repeat);\n            outColor = texture(u_texture, texCoord);\n        }"}createShader(t,e,i){const n=t.createShader(e);return t.shaderSource(n,i),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)?n:(console.error(t.getShaderInfoLog(n)),t.deleteShader(n),null)}createProgram(t,e,i){const n=t.createProgram();return t.attachShader(n,e),t.attachShader(n,i),t.linkProgram(n),t.getProgramParameter(n,t.LINK_STATUS)?n:(console.error(t.getProgramInfoLog(n)),t.deleteProgram(n),null)}initializeWebGL(){const t=this.gl,e=this.createShader(t,t.VERTEX_SHADER,this.vertexShaderSource),i=this.createShader(t,t.FRAGMENT_SHADER,this.fragmentShaderSource);this.program=this.createProgram(t,e,i),this.positionLocation=t.getAttribLocation(this.program,"a_position"),this.texCoordLocation=t.getAttribLocation(this.program,"a_texCoord"),this.resolutionLocation=t.getUniformLocation(this.program,"u_resolution"),this.tileSizeLocation=t.getUniformLocation(this.program,"u_tileSize"),this.positionBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),t.STATIC_DRAW)}updatePointsCanvasSize(t){const e=window.devicePixelRatio||1;t.style.width=`${this.tileSize}px`,t.style.height=`${this.tileSize}px`,t.style.minHeight="unset",t.width=this.tileSize*e,t.height=this.tileSize*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}updateCanvasSize(t){const e=window.devicePixelRatio||1,i=this.clientWidth||300,n=this.clientHeight||300;t.width=i*e,t.height=n*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}render(){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,this.canvas.width,0,0,this.canvas.height,0,this.canvas.height,this.canvas.width,0,this.canvas.width,this.canvas.height]),t.STATIC_DRAW),t.useProgram(this.program),t.enableVertexAttribArray(this.positionLocation),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.vertexAttribPointer(this.positionLocation,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.texCoordLocation),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.vertexAttribPointer(this.texCoordLocation,2,t.FLOAT,!1,0,0),t.uniform2f(this.resolutionLocation,t.canvas.width,t.canvas.height),t.uniform1f(this.tileSizeLocation,this.tileSize),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawArrays(t.TRIANGLES,0,6)}connectedCallback(){new ResizeObserver((()=>{this.updateCanvasSize(this.canvas),this.updatePointsCanvasSize(this.pointsCanvas),this.render()})).observe(this)}disconnectedCallback(){this.resizeObserver&&this.resizeObserver.disconnect()}}customElements.define("mm-alhambra",AlhambraTiled);