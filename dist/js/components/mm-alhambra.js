class PointsRenderer{constructor(t,e,i={}){this.pointsCanvas=t,this.canvas=this.pointsCanvas,this.points=e,this.selectedPoints=[],this.options={dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],selectedColor:[.4,1,.4,.9],lineColor:[0,1,0,.8],hoverScale:1.5,zIndex:999,onLineAdded:null,...i},this.gl=this.pointsCanvas.getContext("webgl2"),this.setupGL(),this.setupInteraction()}setupGL(){const t=this.gl;if(!this.gl)return void console.error("WebGL2 not supported");const e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            layout(location = 1) in float a_isHovered;\n            layout(location = 2) in float a_isSelected;\n            \n            uniform vec2 u_resolution;\n            uniform float u_pointSize;\n            uniform float u_hoverScale;\n            \n            out float v_isHovered;\n            out float v_isSelected;\n            \n            void main() {\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n                \n                v_isHovered = a_isHovered;\n                v_isSelected = a_isSelected;\n                \n                gl_PointSize = u_pointSize * (1.0 + (u_hoverScale - 1.0) * a_isHovered);\n            }\n        "),t.compileShader(e);const i=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(i,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_dotColor;\n            uniform vec4 u_hoverColor;\n            uniform vec4 u_selectedColor;\n            \n            in float v_isHovered;\n            in float v_isSelected;\n            out vec4 fragColor;\n            \n            void main() {\n                vec2 center = gl_PointCoord - vec2(0.5);\n                float dist = length(center);\n                float alpha = smoothstep(0.5, 0.45, dist);\n                \n                vec4 color = mix(\n                    mix(u_dotColor, u_selectedColor, v_isSelected),\n                    u_hoverColor,\n                    v_isHovered\n                );\n                fragColor = vec4(color.rgb, color.a * alpha);\n            }\n        "),t.compileShader(i);const o=t.createShader(t.VERTEX_SHADER);t.shaderSource(o,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            \n            uniform vec2 u_resolution;\n            \n            void main() {\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n            }\n        "),t.compileShader(o);const n=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(n,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_lineColor;\n            out vec4 fragColor;\n            \n            void main() {\n                fragColor = u_lineColor;\n            }\n        "),t.compileShader(n),this.pointProgram=t.createProgram(),t.attachShader(this.pointProgram,e),t.attachShader(this.pointProgram,i),t.linkProgram(this.pointProgram),this.lineProgram=t.createProgram(),t.attachShader(this.lineProgram,o),t.attachShader(this.lineProgram,n),t.linkProgram(this.lineProgram),this.pointUniformLocations={resolution:t.getUniformLocation(this.pointProgram,"u_resolution"),pointSize:t.getUniformLocation(this.pointProgram,"u_pointSize"),hoverScale:t.getUniformLocation(this.pointProgram,"u_hoverScale"),dotColor:t.getUniformLocation(this.pointProgram,"u_dotColor"),hoverColor:t.getUniformLocation(this.pointProgram,"u_hoverColor"),selectedColor:t.getUniformLocation(this.pointProgram,"u_selectedColor")},this.lineUniformLocations={resolution:t.getUniformLocation(this.lineProgram,"u_resolution"),lineColor:t.getUniformLocation(this.lineProgram,"u_lineColor")},this.positionBuffer=t.createBuffer(),this.hoverBuffer=t.createBuffer(),this.selectedBuffer=t.createBuffer(),this.lineBuffer=t.createBuffer(),this.pointVAO=t.createVertexArray(),t.bindVertexArray(this.pointVAO),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer);const r=new Float32Array(this.points.flatMap((t=>[t.x,t.y])));t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer);const s=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,s,t.DYNAMIC_DRAW),t.enableVertexAttribArray(1),t.vertexAttribPointer(1,1,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.selectedBuffer);const a=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,a,t.DYNAMIC_DRAW),t.enableVertexAttribArray(2),t.vertexAttribPointer(2,1,t.FLOAT,!1,0,0),this.lineVAO=t.createVertexArray(),t.bindVertexArray(this.lineVAO),t.bindBuffer(t.ARRAY_BUFFER,this.lineBuffer),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindVertexArray(null)}updateSelectedStates(){const t=this.gl,e=new Float32Array(this.points.length);this.selectedPoints.forEach((t=>{e[t]=1})),t.bindBuffer(t.ARRAY_BUFFER,this.selectedBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}updateLineBuffer(){const t=this.gl,e=window.devicePixelRatio||1;if(this.selectedPoints.length<2)return;const i=[];for(let t=1;t<this.selectedPoints.length;t++){const o=this.points[this.selectedPoints[t-1]],n=this.points[this.selectedPoints[t]];i.push(o.x/e,o.y/e,n.x/e,n.y/e)}t.bindBuffer(t.ARRAY_BUFFER,this.lineBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array(i),t.DYNAMIC_DRAW)}handleClick(t){const e=this.canvas.getBoundingClientRect(),i=window.devicePixelRatio||1,o=(t.clientX-e.left)*i,n=(t.clientY-e.top)*i,r=this.findPointUnderCursor(o,n);if(-1!==r){const t=this.points[r];if(this.selectedPoints.length>0){const e=this.points[this.selectedPoints[this.selectedPoints.length-1]];this.options.onLineAdded&&this.options.onLineAdded(e,t)}this.selectedPoints.push(r),this.updateSelectedStates(),this.render()}}render(){const t=this.gl;t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this.selectedPoints.length>=2&&(t.useProgram(this.lineProgram),t.bindVertexArray(this.lineVAO),t.uniform2f(this.lineUniformLocations.resolution,this.canvas.width,this.canvas.height),t.uniform4fv(this.lineUniformLocations.lineColor,this.options.lineColor),t.lineWidth(2),t.drawArrays(t.LINES,0,2*(this.selectedPoints.length-1))),t.useProgram(this.pointProgram),t.bindVertexArray(this.pointVAO);const e=window.devicePixelRatio||1;t.uniform2f(this.pointUniformLocations.resolution,this.canvas.width*e,this.canvas.height*e),t.uniform1f(this.pointUniformLocations.pointSize,2*this.options.dotRadius*e),t.uniform1f(this.pointUniformLocations.hoverScale,this.options.hoverScale),t.uniform4fv(this.pointUniformLocations.dotColor,this.options.dotColor),t.uniform4fv(this.pointUniformLocations.hoverColor,this.options.hoverColor),t.uniform4fv(this.pointUniformLocations.selectedColor,this.options.selectedColor),t.drawArrays(t.POINTS,0,this.points.length),t.bindVertexArray(null)}setupInteraction(){this.canvas.style.pointerEvents="auto",this.hoveredPointIndex=-1,this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("click",this.handleClick.bind(this))}handleMouseMove(t){const e=this.canvas.getBoundingClientRect(),i=window.devicePixelRatio||1,o=(t.clientX-e.left)*i,n=(t.clientY-e.top)*i,r=this.hoveredPointIndex;this.hoveredPointIndex=this.findPointUnderCursor(o,n),r!==this.hoveredPointIndex&&(this.updateHoverStates(),this.render()),this.canvas.style.cursor=-1!==this.hoveredPointIndex?"pointer":"default"}findPointUnderCursor(t,e){const i=window.devicePixelRatio||1,o=2*this.options.dotRadius*i;return this.points.findIndex((n=>{const r=n.x-t*i,s=n.y-e*i;return r*r+s*s<=o*o}))}updateHoverStates(){const t=this.gl,e=new Float32Array(this.points.length);-1!==this.hoveredPointIndex&&(e[this.hoveredPointIndex]=1),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}cleanup(){const t=this.gl;this.canvas.removeEventListener("mousemove",this.handleMouseMove),this.canvas.removeEventListener("click",this.handleClick),t.deleteBuffer(this.positionBuffer),t.deleteBuffer(this.hoverBuffer),t.deleteProgram(this.program),t.deleteVertexArray(this.vao)}}class AlhambraTiled extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="\n          <canvas data-canvas></canvas>\n          <canvas data-canvas-points></canvas>\n          <style>\n          :host {\n            display: grid;\n            position: relative;\n          }\n          canvas {\n            width: 100%;\n            min-height: 100%;\n            position: absolute;\n            left: 0;\n            top: 0;\n          }\n          </style>",this.canvas=this.shadowRoot.querySelector("canvas"),this.pointsCanvas=this.shadowRoot.querySelector("canvas[data-canvas-points]"),this.selectedLines=new Set,this.gl=this.canvas.getContext("webgl2"),this.gl?(this.updatePointsCanvasSize(this.pointsCanvas),this.pointsRenderer=null,this.points=null,this.textureCanvas=document.createElement("canvas"),this.textureCanvas.width=2048,this.textureCanvas.height=2048,this.textureCtx=this.textureCanvas.getContext("2d"),this.initializeTexture(),this.initializeWebGL(),this.updateCanvasSize(this.canvas),this.render()):console.error("WebGL2 not supported")}addLineToPattern(t,e){const i=this.textureCtx;i.beginPath(),i.strokeStyle="rgba(0, 255, 0, 0.8)",i.lineWidth=2,i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke();const o=this.gl;o.bindTexture(o.TEXTURE_2D,this.texture),o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,this.textureCanvas),this.render()}generateTilePattern(){const t=this.textureCtx,e=this.textureCanvas.width,i=this.textureCanvas.height,o=e/2,n=i/2;let r=new Set;const s=(t,o)=>{if(t>=0&&t<=e&&o>=0&&o<=i){const e=Math.round(1e3*t)/1e3,i=Math.round(1e3*o)/1e3;r.add(`${e},${i}`)}},a=(t,e,i,o,n,r,s,a)=>{const h=(t-i)*(r-a)-(e-o)*(n-s);if(0===h)return null;const c=((t-n)*(r-a)-(e-r)*(n-s))/h,l=-((t-i)*(e-r)-(e-o)*(t-n))/h;if(c>=0&&c<=1&&l>=0&&l<=1){return[t+c*(i-t),e+c*(o-e)]}return null};t.fillStyle="#1a1324",t.fillRect(0,0,e,i),t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1;const h=Math.tan(22.5*Math.PI/180),c=(Math.tan(67.5*Math.PI/180),[[[0,0],[e,i]],[[e,0],[0,i]],[[o,0],[o,i]],[[0,n],[e,n]],[[0,n-o*h],[e,n+o*h]],[[0,n+o*h],[e,n-o*h]],[[o-n*h,0],[o+n*h,i]],[[o+n*h,0],[o-n*h,i]]]);t.beginPath(),c.forEach((([[e,i],[o,n]])=>{t.moveTo(e,i),t.lineTo(o,n)})),t.stroke(),t.beginPath(),t.rect(0,0,e,i),t.stroke();const l=Math.min(e,i)/2;t.beginPath(),t.arc(o,n,l,0,2*Math.PI),t.stroke();const d=e*Math.sqrt(2)/8;t.beginPath(),t.arc(o,n,d,0,2*Math.PI),t.stroke();const u=d*Math.sqrt(2)/2,f=[[[o-u,0],[o-u,i]],[[o+u,0],[o+u,i]],[[0,n-u],[e,n-u]],[[0,n+u],[e,n+u]]];t.beginPath(),f.forEach((([[e,i],[o,n]])=>{t.moveTo(e,i),t.lineTo(o,n)})),t.stroke(),c.push(...f),t.save(),t.translate(o,n),t.rotate(Math.PI/4);const v=[[[-u,-e],[-u,e]],[[u,-e],[u,e]],[[-e,-u],[e,-u]],[[-e,u],[e,u]]];t.beginPath(),v.forEach((([[e,i],[o,n]])=>{t.moveTo(e,i),t.lineTo(o,n)})),t.stroke(),t.restore();const p=Math.cos(Math.PI/4),m=Math.sin(Math.PI/4),g=v.map((([[t,e],[i,r]])=>[[o+(t*p-e*m),n+(t*m+e*p)],[o+(i*p-r*m),n+(i*m+r*p)]]));c.push(...g);const A=e*Math.sqrt(2)/2-l,R=[[o,n,l],[o,n,d],[0,0,A],[e,0,A],[e,i,A],[0,i,A]],P=[[0,Math.PI/2],[Math.PI/2,Math.PI],[Math.PI,3*Math.PI/2],[3*Math.PI/2,2*Math.PI]],_=[[0,0],[e,0],[e,i],[0,i]];P.forEach(((e,i)=>{t.beginPath(),t.arc(_[i][0],_[i][1],A,...e),t.stroke()}));const x=A/Math.sqrt(2),S=[{mid1:[0,n],mid2:[o,0],intersect:[x,x]},{mid1:[e,n],mid2:[o,0],intersect:[e-x,x]},{mid1:[e,n],mid2:[o,i],intersect:[e-x,i-x]},{mid1:[0,n],mid2:[o,i],intersect:[x,i-x]}];function C(t,e,i,o,n,r){const s=i-t,a=o-e,h=a/s;let c,l;return s>0?(c=n,l=e+h*(n-t)):(c=0,l=e+h*(0-t)),(l<0||l>r)&&(l=a>0?r:0,c=t+(l-e)/h),[c,l]}t.beginPath(),S.forEach((o=>{const[n,r]=C(o.mid1[0],o.mid1[1],o.intersect[0],o.intersect[1],e,i);t.moveTo(o.mid1[0],o.mid1[1]),t.lineTo(n,r),c.push([[o.mid1[0],o.mid1[1]],[n,r]]);const[s,a]=C(o.mid2[0],o.mid2[1],o.intersect[0],o.intersect[1],e,i);t.moveTo(o.mid2[0],o.mid2[1]),t.lineTo(s,a),c.push([[o.mid2[0],o.mid2[1]],[s,a]])})),t.stroke();for(let t=0;t<c.length;t++)for(let e=t+1;e<c.length;e++){const i=a(c[t][0][0],c[t][0][1],c[t][1][0],c[t][1][1],c[e][0][0],c[e][0][1],c[e][1][0],c[e][1][1]);i&&s(i[0],i[1])}R.forEach((t=>{c.forEach((e=>{((t,e,i,o,n,r,s)=>{const a=r-o,h=s-n,c=a*a+h*h,l=2*(a*(o-t)+h*(n-e)),d=l*l-4*c*(t*t+e*e+o*o+n*n-2*(t*o+e*n)-i*i);if(d<0)return[];if(0===d){const t=-l/(2*c);return t>=0&&t<=1?[[o+t*a,n+t*h]]:[]}const u=(-l+Math.sqrt(d))/(2*c),f=(-l-Math.sqrt(d))/(2*c),v=[];return u>=0&&u<=1&&v.push([o+u*a,n+u*h]),f>=0&&f<=1&&v.push([o+f*a,n+f*h]),v})(t[0],t[1],t[2],e[0][0],e[0][1],e[1][0],e[1][1]).forEach((t=>s(t[0],t[1])))}))})),this.points=Array.from(r).map((t=>{const[e,i]=t.split(",").map(Number);return{x:e,y:i}})),console.log(this.points)}createPointsRenderer(t){this.pointsRenderer=new PointsRenderer(this.pointsCanvas,t,{dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],hoverScale:1.5,onLineAdded:(t,e)=>{this.addLineToPattern(t,e)}}),this.pointsRenderer.render()}initializeTexture(){this.generateTilePattern();const t=this.gl;this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.textureCanvas),this.createPointsRenderer(this.points)}get vertexShaderSource(){return"#version 300 es\n        in vec4 a_position;\n        in vec2 a_texCoord;\n        uniform vec2 u_resolution;\n        out vec2 v_texCoord;\n        \n        void main() {\n            vec2 zeroToOne = a_position.xy / u_resolution;\n            vec2 clipSpace = (zeroToOne * 2.0 - 1.0) * vec2(1, -1);\n            gl_Position = vec4(clipSpace, 0, 1);\n            v_texCoord = a_texCoord;\n        }"}get fragmentShaderSource(){return"#version 300 es\n        precision highp float;\n        \n        in vec2 v_texCoord;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        out vec4 outColor;\n        \n        void main() {\n            vec2 repeat = u_resolution / 1024.0;  // 512 is texture size\n            vec2 texCoord = fract(v_texCoord * repeat);\n            outColor = texture(u_texture, texCoord);\n        }"}createShader(t,e,i){const o=t.createShader(e);return t.shaderSource(o,i),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)?o:(console.error(t.getShaderInfoLog(o)),t.deleteShader(o),null)}createProgram(t,e,i){const o=t.createProgram();return t.attachShader(o,e),t.attachShader(o,i),t.linkProgram(o),t.getProgramParameter(o,t.LINK_STATUS)?o:(console.error(t.getProgramInfoLog(o)),t.deleteProgram(o),null)}initializeWebGL(){const t=this.gl,e=this.createShader(t,t.VERTEX_SHADER,this.vertexShaderSource),i=this.createShader(t,t.FRAGMENT_SHADER,this.fragmentShaderSource);this.program=this.createProgram(t,e,i),this.positionLocation=t.getAttribLocation(this.program,"a_position"),this.texCoordLocation=t.getAttribLocation(this.program,"a_texCoord"),this.resolutionLocation=t.getUniformLocation(this.program,"u_resolution"),this.positionBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),t.STATIC_DRAW)}updateCanvasSize(t){const e=window.devicePixelRatio||1,i=this.clientWidth||300,o=this.clientHeight||300;t.width=i*e,t.height=o*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}updatePointsCanvasSize(t){const e=window.devicePixelRatio||1,i=512;t.style.width="512px",t.style.height="512px",t.style.minHeight="unset",t.width=i*e,t.height=i*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}render(){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,this.canvas.width,0,0,this.canvas.height,0,this.canvas.height,this.canvas.width,0,this.canvas.width,this.canvas.height]),t.STATIC_DRAW),t.useProgram(this.program),t.enableVertexAttribArray(this.positionLocation),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.vertexAttribPointer(this.positionLocation,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.texCoordLocation),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.vertexAttribPointer(this.texCoordLocation,2,t.FLOAT,!1,0,0),t.uniform2f(this.resolutionLocation,t.canvas.width,t.canvas.height),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawArrays(t.TRIANGLES,0,6)}connectedCallback(){new ResizeObserver((()=>{this.updateCanvasSize(this.canvas),this.updatePointsCanvasSize(this.pointsCanvas),this.render()})).observe(this)}disconnectedCallback(){this.resizeObserver&&this.resizeObserver.disconnect()}}customElements.define("mm-alhambra",AlhambraTiled);