const defaultPattern="point1,point2\n5,80\n54,80\n15,54\n15,39\n39,77\n0,77\n0,13\n1,13\n1,74\n53,74\n16,53\n16,40\n40,75\n4,75\n6,67\n33,67\n9,33\n9,47\n47,66\n3,66\n3,19\n2,19\n2,69\n34,69\n10,34\n10,48\n48,72\n7,72\n7,20\n31,61\n31,64\n15,64\n24,54\n24,48\n48,63\n32,63\n32,62\n16,62\n16,59\n25,59\n25,57\n9,57\n9,61\n15,58\n26,58\n26,60\n10,60";class PointsRenderer{constructor(t,e,n={}){this.pointsCanvas=t,this.canvas=this.pointsCanvas,this.points=e,this.isDrawingEnabled=!1,this.selectedPoints=[],this.lineConnections=new Set,this.options={dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],selectedColor:[.4,1,.4,.9],lineColor:[0,1,0,.8],hoverScale:1.5,zIndex:999,onLineAdded:null,onExportCSV:null,onImportCSV:null,onDrawingStateChanged:null,...n},this.gl=this.pointsCanvas.getContext("webgl2"),this.setupGL(),this.setupInteraction(),this.importFromCSV(defaultPattern)}setDrawingMode(t){this.isDrawingEnabled=t,t||(this.selectedPoints=[],this.updateSelectedStates(),this.render()),this.updateCursor(),this.options.onDrawingStateChanged&&this.options.onDrawingStateChanged(t)}updateCursor(){this.isDrawingEnabled?-1!==this.hoveredPointIndex?this.canvas.style.cursor='url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23ffffff" stroke-width="2"><circle cx="12" cy="12" r="3"/><circle cx="12" cy="12" r="8" stroke-dasharray="2"/></svg>\') 12 12, crosshair':this.canvas.style.cursor="crosshair":this.canvas.style.cursor=-1!==this.hoveredPointIndex?"pointer":"default"}exportToCSV(){return"point1,point2\n"+Array.from(this.lineConnections).map((t=>{const[e,n]=t.split(",");return`${e},${n}`})).join("\n")}importFromCSV(t){this.lineConnections.clear(),this.selectedPoints=[];t.split("\n").slice(1).forEach((t=>{if(t.trim()){const[e,n]=t.split(",").map(Number);if(!isNaN(e)&&!isNaN(n)){this.lineConnections.add(`${e},${n}`),this.selectedPoints.includes(e)||this.selectedPoints.push(e),this.selectedPoints.includes(n)||this.selectedPoints.push(n);const t=this.points[e],i=this.points[n];this.options.onLineAdded&&this.options.onLineAdded(t,i)}}})),this.updateSelectedStates(),this.render()}setupGL(){const t=this.gl;if(!this.gl)return void console.error("WebGL2 not supported");const e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            layout(location = 1) in float a_isHovered;\n            layout(location = 2) in float a_isSelected;\n            \n            uniform vec2 u_resolution;\n            uniform float u_pointSize;\n            uniform float u_hoverScale;\n            \n            out float v_isHovered;\n            out float v_isSelected;\n            \n            void main() {\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n                \n                v_isHovered = a_isHovered;\n                v_isSelected = a_isSelected;\n                \n                gl_PointSize = u_pointSize * (1.0 + (u_hoverScale - 1.0) * a_isHovered);\n            }\n        "),t.compileShader(e);const n=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(n,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_dotColor;\n            uniform vec4 u_hoverColor;\n            uniform vec4 u_selectedColor;\n            \n            in float v_isHovered;\n            in float v_isSelected;\n            out vec4 fragColor;\n            \n            void main() {\n                vec2 center = gl_PointCoord - vec2(0.5);\n                float dist = length(center);\n                float alpha = smoothstep(0.5, 0.45, dist);\n                \n                vec4 color = mix(\n                    mix(u_dotColor, u_selectedColor, v_isSelected),\n                    u_hoverColor,\n                    v_isHovered\n                );\n                fragColor = vec4(color.rgb, color.a * alpha);\n            }\n        "),t.compileShader(n);const i=t.createShader(t.VERTEX_SHADER);t.shaderSource(i,"#version 300 es\n            layout(location = 0) in vec2 a_position;\n            \n            uniform vec2 u_resolution;\n            \n            void main() {\n                vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n            }\n        "),t.compileShader(i);const o=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(o,"#version 300 es\n            precision highp float;\n            \n            uniform vec4 u_lineColor;\n            out vec4 fragColor;\n            \n            void main() {\n                fragColor = u_lineColor;\n            }\n        "),t.compileShader(o),this.pointProgram=t.createProgram(),t.attachShader(this.pointProgram,e),t.attachShader(this.pointProgram,n),t.linkProgram(this.pointProgram),this.lineProgram=t.createProgram(),t.attachShader(this.lineProgram,i),t.attachShader(this.lineProgram,o),t.linkProgram(this.lineProgram),this.pointUniformLocations={resolution:t.getUniformLocation(this.pointProgram,"u_resolution"),pointSize:t.getUniformLocation(this.pointProgram,"u_pointSize"),hoverScale:t.getUniformLocation(this.pointProgram,"u_hoverScale"),dotColor:t.getUniformLocation(this.pointProgram,"u_dotColor"),hoverColor:t.getUniformLocation(this.pointProgram,"u_hoverColor"),selectedColor:t.getUniformLocation(this.pointProgram,"u_selectedColor")},this.lineUniformLocations={resolution:t.getUniformLocation(this.lineProgram,"u_resolution"),lineColor:t.getUniformLocation(this.lineProgram,"u_lineColor")},this.positionBuffer=t.createBuffer(),this.hoverBuffer=t.createBuffer(),this.selectedBuffer=t.createBuffer(),this.lineBuffer=t.createBuffer(),this.pointVAO=t.createVertexArray(),t.bindVertexArray(this.pointVAO),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer);const r=new Float32Array(this.points.flatMap((t=>[t.x,t.y])));t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer);const s=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,s,t.DYNAMIC_DRAW),t.enableVertexAttribArray(1),t.vertexAttribPointer(1,1,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.selectedBuffer);const a=new Float32Array(this.points.length);t.bufferData(t.ARRAY_BUFFER,a,t.DYNAMIC_DRAW),t.enableVertexAttribArray(2),t.vertexAttribPointer(2,1,t.FLOAT,!1,0,0),this.lineVAO=t.createVertexArray(),t.bindVertexArray(this.lineVAO),t.bindBuffer(t.ARRAY_BUFFER,this.lineBuffer),t.enableVertexAttribArray(0),t.vertexAttribPointer(0,2,t.FLOAT,!1,0,0),t.bindVertexArray(null)}updateSelectedStates(){const t=this.gl,e=new Float32Array(this.points.length);this.selectedPoints.forEach((t=>{e[t]=1})),t.bindBuffer(t.ARRAY_BUFFER,this.selectedBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}updateLineBuffer(){const t=this.gl,e=window.devicePixelRatio||1;if(this.selectedPoints.length<2)return;const n=[];for(let t=1;t<this.selectedPoints.length;t++){const i=this.points[this.selectedPoints[t-1]],o=this.points[this.selectedPoints[t]];n.push(i.x/e,i.y/e,o.x/e,o.y/e)}t.bindBuffer(t.ARRAY_BUFFER,this.lineBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array(n),t.DYNAMIC_DRAW)}handleClick(t){if(!this.isDrawingEnabled)return;const e=this.canvas.getBoundingClientRect(),n=window.devicePixelRatio||1,i=(t.clientX-e.left)*n,o=(t.clientY-e.top)*n,r=this.findPointUnderCursor(i,o);if(-1!==r){const t=this.points[r];if(this.selectedPoints.length>0){const e=this.selectedPoints[this.selectedPoints.length-1],n=[e,r].sort(((t,e)=>t-e)).join(",");if(this.lineConnections.add(n),this.options.onLineAdded){const n=this.points[e];this.options.onLineAdded(n,t)}}this.selectedPoints.push(r),this.updateSelectedStates(),this.render()}}render(){const t=this.gl;t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this.selectedPoints.length>=2&&(t.useProgram(this.lineProgram),t.bindVertexArray(this.lineVAO),t.uniform2f(this.lineUniformLocations.resolution,this.canvas.width,this.canvas.height),t.uniform4fv(this.lineUniformLocations.lineColor,this.options.lineColor),t.lineWidth(2),t.drawArrays(t.LINES,0,2*(this.selectedPoints.length-1))),t.useProgram(this.pointProgram),t.bindVertexArray(this.pointVAO);const e=window.devicePixelRatio||1;t.uniform2f(this.pointUniformLocations.resolution,this.canvas.width*e,this.canvas.height*e),t.uniform1f(this.pointUniformLocations.pointSize,2*this.options.dotRadius*e),t.uniform1f(this.pointUniformLocations.hoverScale,this.options.hoverScale),t.uniform4fv(this.pointUniformLocations.dotColor,this.options.dotColor),t.uniform4fv(this.pointUniformLocations.hoverColor,this.options.hoverColor),t.uniform4fv(this.pointUniformLocations.selectedColor,this.options.selectedColor),t.drawArrays(t.POINTS,0,this.points.length),t.bindVertexArray(null)}setupInteraction(){this.canvas.style.pointerEvents="auto",this.hoveredPointIndex=-1,this.canvas.addEventListener("mousemove",this.handleMouseMove.bind(this)),this.canvas.addEventListener("click",this.handleClick.bind(this))}handleMouseMove(t){const e=this.canvas.getBoundingClientRect(),n=window.devicePixelRatio||1,i=(t.clientX-e.left)*n,o=(t.clientY-e.top)*n,r=this.hoveredPointIndex;this.hoveredPointIndex=this.findPointUnderCursor(i,o),r!==this.hoveredPointIndex&&(this.updateHoverStates(),this.updateCursor(),this.render())}findPointUnderCursor(t,e){const n=window.devicePixelRatio||1,i=2*this.options.dotRadius*n;return this.points.findIndex((o=>{const r=o.x-t*n,s=o.y-e*n;return r*r+s*s<=i*i}))}updateHoverStates(){const t=this.gl,e=new Float32Array(this.points.length);-1!==this.hoveredPointIndex&&(e[this.hoveredPointIndex]=1),t.bindBuffer(t.ARRAY_BUFFER,this.hoverBuffer),t.bufferSubData(t.ARRAY_BUFFER,0,e)}cleanup(){const t=this.gl;this.canvas.removeEventListener("mousemove",this.handleMouseMove),this.canvas.removeEventListener("click",this.handleClick),t.deleteBuffer(this.positionBuffer),t.deleteBuffer(this.hoverBuffer),t.deleteProgram(this.program),t.deleteVertexArray(this.vao)}}class AlhambraTiled extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="\n          <canvas data-canvas></canvas>\n          <canvas data-canvas-points></canvas>\n          <style>\n          :host {\n            display: grid;\n            position: relative;\n          }\n          canvas {\n            width: 100%;\n            min-height: 100%;\n            position: absolute;\n            left: 0;\n            top: 0;\n          }\n          </style>",this.canvas=this.shadowRoot.querySelector("canvas"),this.pointsCanvas=this.shadowRoot.querySelector("canvas[data-canvas-points]"),this.selectedLines=new Set,this.gl=this.canvas.getContext("webgl2"),this.gl?(this.updatePointsCanvasSize(this.pointsCanvas),this.pointsRenderer=null,this.points=null,this.textureCanvas=document.createElement("canvas"),this.textureCanvas.width=2048,this.textureCanvas.height=2048,this.textureCtx=this.textureCanvas.getContext("2d"),this.initializeTexture(),this.initializeWebGL(),this.updateCanvasSize(this.canvas),this.render(),this.setupExportImport(),this.setupDrawControls()):console.error("WebGL2 not supported")}setupDrawControls(){const t=document.createElement("div");t.style.cssText="\n            position: absolute;\n            bottom: 10px;\n            left: 200px;\n            display: flex;\n            gap: 10px;\n            z-index: 1000;\n        ";const e=document.createElement("button");e.textContent="Start Drawing",e.onclick=()=>this.setDrawingMode(!0);const n=document.createElement("button");n.textContent="Stop Drawing",n.onclick=()=>this.setDrawingMode(!1),n.style.display="none",this.drawButtons={start:e,stop:n},t.appendChild(e),t.appendChild(n),this.shadowRoot.appendChild(t)}setDrawingMode(t){this.pointsRenderer&&(this.pointsRenderer.setDrawingMode(t),this.drawButtons.start.style.display=t?"none":"block",this.drawButtons.stop.style.display=t?"block":"none")}setupExportImport(){const t=document.createElement("div");t.style.cssText="\n            position: absolute;\n            bottom: 10px;\n            right: 10px;\n            display: flex;\n            gap: 10px;\n            z-index: 1000;\n        ";const e=document.createElement("button");e.textContent="Export CSV",e.onclick=()=>this.exportPattern();const n=document.createElement("button");n.textContent="Import CSV",n.onclick=()=>this.importPattern();const i=document.createElement("input");i.type="file",i.accept=".csv",i.style.display="none",i.onchange=t=>this.handleFileImport(t),t.appendChild(e),t.appendChild(n),t.appendChild(i),this.shadowRoot.appendChild(t),this.fileInput=i}addLineToPattern(t,e){const n=this.textureCtx;n.beginPath(),n.strokeStyle="rgba(0, 255, 0, 0.8)",n.lineWidth=2,n.moveTo(t.x,t.y),n.lineTo(e.x,e.y),n.stroke();const i=this.gl;i.bindTexture(i.TEXTURE_2D,this.texture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,this.textureCanvas),this.render()}generateTilePattern(){const t=this.textureCtx,e=this.textureCanvas.width,n=this.textureCanvas.height,i=e/2,o=n/2;let r=new Set;const s=(t,i)=>{{const o=Math.max(0,Math.min(e,t)),s=Math.max(0,Math.min(n,i)),a=Math.round(1e3*o)/1e3,h=Math.round(1e3*s)/1e3;r.add(`${a},${h}`)}},a=(t,e,n,i,o,r,s,a)=>{const h=(t-n)*(r-a)-(e-i)*(o-s);if(0===h)return null;const l=((t-o)*(r-a)-(e-r)*(o-s))/h,c=-((t-n)*(e-r)-(e-i)*(t-o))/h;if(l>=0&&l<=1&&c>=0&&c<=1){return[t+l*(n-t),e+l*(i-e)]}return null};t.fillStyle="#1a1324",t.fillRect(0,0,e,n),t.strokeStyle="rgba(255, 255, 255, 0.3)",t.lineWidth=1;const h=Math.tan(22.5*Math.PI/180),l=(Math.tan(67.5*Math.PI/180),[[[0,0],[e,n]],[[e,0],[0,n]],[[i,0],[i,n]],[[0,o],[e,o]],[[0,o-i*h],[e,o+i*h]],[[0,o+i*h],[e,o-i*h]],[[i-o*h,0],[i+o*h,n]],[[i+o*h,0],[i-o*h,n]]]);t.beginPath(),l.forEach((([[e,n],[i,o]])=>{t.moveTo(e,n),t.lineTo(i,o)})),t.stroke(),t.beginPath(),t.rect(0,0,e,n),t.stroke();const c=Math.min(e,n)/2;t.beginPath(),t.arc(i,o,c,0,2*Math.PI),t.stroke();const d=e*Math.sqrt(2)/8;t.beginPath(),t.arc(i,o,d,0,2*Math.PI),t.stroke();const u=d*Math.sqrt(2)/2,p=[[[i-u,0],[i-u,n]],[[i+u,0],[i+u,n]],[[0,o-u],[e,o-u]],[[0,o+u],[e,o+u]]];t.beginPath(),p.forEach((([[e,n],[i,o]])=>{t.moveTo(e,n),t.lineTo(i,o)})),t.stroke(),l.push(...p),t.save(),t.translate(i,o),t.rotate(Math.PI/4);const f=[[[-u,-e],[-u,e]],[[u,-e],[u,e]],[[-e,-u],[e,-u]],[[-e,u],[e,u]]];t.beginPath(),f.forEach((([[e,n],[i,o]])=>{t.moveTo(e,n),t.lineTo(i,o)})),t.stroke(),t.restore();const v=Math.cos(Math.PI/4),m=Math.sin(Math.PI/4),g=f.map((([[t,e],[n,r]])=>[[i+(t*v-e*m),o+(t*m+e*v)],[i+(n*v-r*m),o+(n*m+r*v)]]));l.push(...g);const x=e*Math.sqrt(2)/2-c,R=[[i,o,c],[i,o,d],[0,0,x],[e,0,x],[e,n,x],[0,n,x]];s(x,0),s(0,x),s(e-x,0),s(e,x),s(e-x,n),s(e,n-x),s(x,n),s(0,n-x);const A=[[0,Math.PI/2],[Math.PI/2,Math.PI],[Math.PI,3*Math.PI/2],[3*Math.PI/2,2*Math.PI]],C=[[0,0],[e,0],[e,n],[0,n]];A.forEach(((e,n)=>{t.beginPath(),t.arc(C[n][0],C[n][1],x,...e),t.stroke()}));const P=x/Math.sqrt(2),S=[{mid1:[0,o],mid2:[i,0],intersect:[P,P]},{mid1:[e,o],mid2:[i,0],intersect:[e-P,P]},{mid1:[e,o],mid2:[i,n],intersect:[e-P,n-P]},{mid1:[0,o],mid2:[i,n],intersect:[P,n-P]}];function _(t,e,n,i,o,r){const s=n-t,a=i-e,h=a/s;let l,c;return s>0?(l=o,c=e+h*(o-t)):(l=0,c=e+h*(0-t)),(c<0||c>r)&&(c=a>0?r:0,l=t+(c-e)/h),[l,c]}t.beginPath(),S.forEach((i=>{const[o,r]=_(i.mid1[0],i.mid1[1],i.intersect[0],i.intersect[1],e,n);t.moveTo(i.mid1[0],i.mid1[1]),t.lineTo(o,r),l.push([[i.mid1[0],i.mid1[1]],[o,r]]);const[s,a]=_(i.mid2[0],i.mid2[1],i.intersect[0],i.intersect[1],e,n);t.moveTo(i.mid2[0],i.mid2[1]),t.lineTo(s,a),l.push([[i.mid2[0],i.mid2[1]],[s,a]])})),t.stroke();for(let t=0;t<l.length;t++)for(let e=t+1;e<l.length;e++){const n=a(l[t][0][0],l[t][0][1],l[t][1][0],l[t][1][1],l[e][0][0],l[e][0][1],l[e][1][0],l[e][1][1]);n&&s(n[0],n[1])}R.forEach((t=>{l.forEach((e=>{((t,e,n,i,o,r,s)=>{const a=r-i,h=s-o,l=a*a+h*h,c=2*(a*(i-t)+h*(o-e)),d=c*c-4*l*(t*t+e*e+i*i+o*o-2*(t*i+e*o)-n*n);if(d<0)return[];if(0===d){const t=-c/(2*l);return t>=0&&t<=1?[[i+t*a,o+t*h]]:[]}const u=(-c+Math.sqrt(d))/(2*l),p=(-c-Math.sqrt(d))/(2*l),f=[];return u>=0&&u<=1&&f.push([i+u*a,o+u*h]),p>=0&&p<=1&&f.push([i+p*a,o+p*h]),f})(t[0],t[1],t[2],e[0][0],e[0][1],e[1][0],e[1][1]).forEach((t=>s(t[0],t[1])))}))})),this.points=Array.from(r).map((t=>{const[e,n]=t.split(",").map(Number);return{x:e,y:n}})),console.log(this.points)}exportPattern(){if(this.pointsRenderer){const t=this.pointsRenderer.exportToCSV(),e=new Blob([t],{type:"text/csv"}),n=window.URL.createObjectURL(e),i=document.createElement("a");i.href=n,i.download="alhambra_pattern.csv",i.click(),window.URL.revokeObjectURL(n)}}importPattern(){this.fileInput.click()}handleFileImport(t){const e=t.target.files[0];if(e){const t=new FileReader;t.onload=t=>{const e=t.target.result;this.resetPattern(),this.pointsRenderer.importFromCSV(e)},t.readAsText(e)}}resetPattern(){this.textureCtx.clearRect(0,0,this.textureCanvas.width,this.textureCanvas.height),this.generateTilePattern();const t=this.gl;t.bindTexture(t.TEXTURE_2D,this.texture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.textureCanvas),this.render()}createPointsRenderer(t){this.pointsRenderer=new PointsRenderer(this.pointsCanvas,t,{dotRadius:3,dotColor:[1,.4,.4,.7],hoverColor:[1,.8,.4,.9],hoverScale:1.5,onLineAdded:(t,e)=>{this.addLineToPattern(t,e)},onDrawingStateChanged:t=>{this.drawButtons.start.style.display=t?"none":"block",this.drawButtons.stop.style.display=t?"block":"none"}}),this.pointsRenderer.render()}initializeTexture(){this.generateTilePattern();const t=this.gl;this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.textureCanvas),this.createPointsRenderer(this.points)}get vertexShaderSource(){return"#version 300 es\n        in vec4 a_position;\n        in vec2 a_texCoord;\n        uniform vec2 u_resolution;\n        out vec2 v_texCoord;\n        \n        void main() {\n            vec2 zeroToOne = a_position.xy / u_resolution;\n            vec2 clipSpace = (zeroToOne * 2.0 - 1.0) * vec2(1, -1);\n            gl_Position = vec4(clipSpace, 0, 1);\n            v_texCoord = a_texCoord;\n        }"}get fragmentShaderSource(){return"#version 300 es\n        precision highp float;\n        \n        in vec2 v_texCoord;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        out vec4 outColor;\n        \n        void main() {\n            vec2 repeat = u_resolution / 1024.0;  // 512 is texture size\n            vec2 texCoord = fract(v_texCoord * repeat);\n            outColor = texture(u_texture, texCoord);\n        }"}createShader(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),t.getShaderParameter(i,t.COMPILE_STATUS)?i:(console.error(t.getShaderInfoLog(i)),t.deleteShader(i),null)}createProgram(t,e,n){const i=t.createProgram();return t.attachShader(i,e),t.attachShader(i,n),t.linkProgram(i),t.getProgramParameter(i,t.LINK_STATUS)?i:(console.error(t.getProgramInfoLog(i)),t.deleteProgram(i),null)}initializeWebGL(){const t=this.gl,e=this.createShader(t,t.VERTEX_SHADER,this.vertexShaderSource),n=this.createShader(t,t.FRAGMENT_SHADER,this.fragmentShaderSource);this.program=this.createProgram(t,e,n),this.positionLocation=t.getAttribLocation(this.program,"a_position"),this.texCoordLocation=t.getAttribLocation(this.program,"a_texCoord"),this.resolutionLocation=t.getUniformLocation(this.program,"u_resolution"),this.positionBuffer=t.createBuffer(),this.texCoordBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),t.STATIC_DRAW)}updateCanvasSize(t){const e=window.devicePixelRatio||1,n=this.clientWidth||300,i=this.clientHeight||300;t.width=n*e,t.height=i*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}updatePointsCanvasSize(t){const e=window.devicePixelRatio||1,n=512;t.style.width="512px",t.style.height="512px",t.style.minHeight="unset",t.width=n*e,t.height=n*e,t.getContext("webgl2").viewport(0,0,t.width,t.height)}render(){const t=this.gl;t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,this.canvas.width,0,0,this.canvas.height,0,this.canvas.height,this.canvas.width,0,this.canvas.width,this.canvas.height]),t.STATIC_DRAW),t.useProgram(this.program),t.enableVertexAttribArray(this.positionLocation),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.vertexAttribPointer(this.positionLocation,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.texCoordLocation),t.bindBuffer(t.ARRAY_BUFFER,this.texCoordBuffer),t.vertexAttribPointer(this.texCoordLocation,2,t.FLOAT,!1,0,0),t.uniform2f(this.resolutionLocation,t.canvas.width,t.canvas.height),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.drawArrays(t.TRIANGLES,0,6)}connectedCallback(){new ResizeObserver((()=>{this.updateCanvasSize(this.canvas),this.updatePointsCanvasSize(this.pointsCanvas),this.render()})).observe(this)}disconnectedCallback(){this.resizeObserver&&this.resizeObserver.disconnect()}}customElements.define("mm-alhambra",AlhambraTiled);