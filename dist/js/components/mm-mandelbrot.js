class MandelbrotSet extends HTMLElement{static get observedAttributes(){return["animate"]}attributeChangedCallback(t,i,o){"animate"===t&&("true"===o?this.startZoom():this.stopZoom())}connectedCallback(){this.attachShadow({mode:"open"}),this.zoomFactor=1,this.zoomSpeed=1.005,this.centerX=-.743643887037151,this.centerY=.13182590420533,this.canvas=document.createElement("canvas"),this.shadowRoot.innerHTML="<style>\n            :host {\n                display: block;\n                width: 100vh;\n                height: 100%;\n            }\n            canvas {\n                width: 100%;\n                height: 100%;\n            }\n        </style>",this.shadowRoot.appendChild(this.canvas),this.gl=this.canvas.getContext("webgl2"),this.gl?(this.initWebGL(),this.resize(),this.render(),window.addEventListener("resize",(()=>this.resize())),"true"===this.getAttribute("animate")&&this.startZoom()):console.error("WebGL 2 not supported")}initWebGL(){const t=this.createShader(this.gl,this.gl.VERTEX_SHADER,"#version 300 es\n            in vec4 a_position;\n            void main() {\n                gl_Position = a_position;\n            }\n        "),i=this.createShader(this.gl,this.gl.FRAGMENT_SHADER,"#version 300 es\n            precision highp float;\n            uniform float u_zoomFactor;\n            uniform vec2 u_center;\n            uniform vec2 u_resolution;\n            out vec4 outColor;\n\n            vec3 getColor(int iterations, int maxIterations) {\n                float t = float(iterations) / float(maxIterations);\n                float r = 9.0 * (1.0 - t) * t * t * t;\n                float g = 15.0 * (1.0 - t) * (1.0 - t) * t * t;\n                float b = 8.5 * (1.0 - t) * (1.0 - t) * (1.0 - t) * t;\n                return vec3(r, g, b);\n            }\n\n            void main() {\n                vec2 c = (gl_FragCoord.xy - u_resolution / 2.0) * 4.0 / (u_resolution * (u_zoomFactor * 0.5)) + u_center;\n                vec2 z = vec2(0.0);\n                int maxIterations = int(min(200.0, max(u_zoomFactor, 30.)));; // Dynamically adjust iterations\n                int i;\n                for (i = 0; i < maxIterations; i++) {\n                    vec2 z2 = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n                    if (dot(z2, z2) > 4.0) break;\n                    z = z2;\n                }\n                outColor = vec4(getColor(i, maxIterations), 1.0);\n            }\n        ");this.program=this.createProgram(this.gl,t,i),this.positionLocation=this.gl.getAttribLocation(this.program,"a_position"),this.zoomFactorLocation=this.gl.getUniformLocation(this.program,"u_zoomFactor"),this.centerLocation=this.gl.getUniformLocation(this.program,"u_center"),this.resolutionLocation=this.gl.getUniformLocation(this.program,"u_resolution"),this.positionBuffer=this.gl.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer);this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),this.gl.STATIC_DRAW)}createShader(t,i,o){const e=t.createShader(i);return t.shaderSource(e,o),t.compileShader(e),t.getShaderParameter(e,t.COMPILE_STATUS)?e:(console.error(t.getShaderInfoLog(e)),t.deleteShader(e),null)}createProgram(t,i,o){const e=t.createProgram();return t.attachShader(e,i),t.attachShader(e,o),t.linkProgram(e),t.getProgramParameter(e,t.LINK_STATUS)?e:(console.error(t.getProgramInfoLog(e)),t.deleteProgram(e),null)}startZoom(){if(!this.zooming){this.zooming=!0;const t=i=>{this.zooming&&(this.zoomFactor*=this.zoomSpeed,this.render(),requestAnimationFrame(t))};requestAnimationFrame(t)}}stopZoom(){this.zooming=!1}render(){const t=this.gl;t.clear(t.COLOR_BUFFER_BIT),t.useProgram(this.program),t.enableVertexAttribArray(this.positionLocation),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),t.vertexAttribPointer(this.positionLocation,2,t.FLOAT,!1,0,0),t.uniform1f(this.zoomFactorLocation,this.zoomFactor),t.uniform2f(this.centerLocation,this.centerX,this.centerY),t.uniform2f(this.resolutionLocation,t.drawingBufferWidth,t.drawingBufferHeight),t.drawArrays(t.TRIANGLES,0,6)}resize(){const t=window.devicePixelRatio||1,i=Math.floor(this.canvas.clientWidth*t),o=Math.floor(this.canvas.clientHeight*t);this.canvas.width===i&&this.canvas.height===o||(this.canvas.width=i,this.canvas.height=o,this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight),this.render())}}customElements.define("mm-mandelbrot",MandelbrotSet);