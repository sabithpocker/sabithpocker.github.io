class Sierpinski extends HTMLElement{constructor(){super(),this.simpleShader=null,this.vertexShaderSource="\n        attribute vec2 a_position;\n        varying vec4 v_color;\n        uniform vec2 u_resolution;\n       \n        void main() {\n          // convert the position from pixels to 0.0 to 1.0\n          vec2 zeroToOne = a_position / u_resolution;\n       \n          // convert from 0->1 to 0->2\n          vec2 zeroToTwo = zeroToOne * 2.0;\n       \n          // convert from 0->2 to -1->+1 (clipspace)\n          vec2 clipSpace = zeroToTwo - 1.0;\n       \n          gl_Position = vec4(clipSpace, 0, 1);\n      \n          v_color = vec4(0.5, 0.5, 0.5, 1);\n        }\n        ",this.fragmentShaderSource="\n        // fragment shaders don't have a default precision so we need\n        // to pick one. mediump is a good default\n        precision mediump float;\n        uniform vec4 u_color;\n        varying vec4 v_color;\n        void main() {\n          // gl_FragColor is a special variable a fragment shader\n          // is responsible for setting\n          gl_FragColor = v_color; // return redish-purple\n        }\n        ",this.attachShadow({mode:"open"}),this.shadowRoot.innerHTML="\n        <canvas data-canvas></canvas>\n        <style>\n        :host {\n          display: grid;\n        }\n        canvas {\n          width: 100%;\n          min-height: 100%;\n        }\n        </style>\n        "}connectedCallback(){const t=parseInt(this.getAttribute("depth"))||5,e=parseInt(this.getAttribute("min-side-length"))||500,i=parseInt(this.getAttribute("max-side-length"))||600,r=this.getAttribute("color")||"0.1, 0.2, 0.5";this.initializeWebGL(),this.drawSierpinski(t,e,i,r)}initializeWebGL(){const t=this.shadowRoot.querySelector("[data-canvas]");this.resize(t),this.gl=t.getContext("webgl");const e=this.getProgram(this.gl,this.vertexShaderSource,this.fragmentShaderSource),i=this.gl.getAttribLocation(e,"a_position"),r=this.gl.getUniformLocation(e,"u_resolution"),n=this.gl.getUniformLocation(e,"u_color"),a=this.gl.createBuffer();this.simpleShader={program:e,positionAttributeLocation:i,resolutionUniformLocation:r,colorUniformLocation:n,positionBuffer:a},this.gl.useProgram(e),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.uniform2f(r,this.gl.canvas.width,this.gl.canvas.height),this.gl.uniform4f(n,.1,.2,.5,1),this.gl.enableVertexAttribArray(i),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,a)}drawSierpinski(t,e,i,r){console.log("draw sierpinski");const n=this.gl.canvas.width,a=this.gl.canvas.height,o={x:n/2,y:Math.sqrt(3)/2*a/2},s=this.getEquilateralPoints(o,a),h=this.getChildTrianglePoints(s,t),l=r.split(",").map(parseFloat);h.forEach((t=>this.drawTriangle(this.simpleShader,...t,l)))}getRandomSideLength(t,e){return Math.random()*(e-t)+t}getProgram(){const t=this.createShader(this.gl,this.gl.VERTEX_SHADER,this.vertexShaderSource),e=this.createShader(this.gl,this.gl.FRAGMENT_SHADER,this.fragmentShaderSource);return this.createProgram(this.gl,t,e)}createShader(t,e,i){const r=t.createShader(e);t.shaderSource(r,i),t.compileShader(r);if(t.getShaderParameter(r,t.COMPILE_STATUS))return r;t.deleteShader(r)}clearCanvas(t=[0,0,0,0],e){e.clearColor(...t),e.clear(e.COLOR_BUFFER_BIT)}resize(t){const e=window.devicePixelRatio||1,i=Math.floor(t.clientWidth*e),r=Math.floor(t.clientHeight*e);t.width===i&&t.height===r||(t.width=i,t.height=r)}createProgram(t,e,i){var r=t.createProgram();if(t.attachShader(r,e),t.attachShader(r,i),t.linkProgram(r),t.getProgramParameter(r,t.LINK_STATUS))return r;console.log(t.getProgramInfoLog(r)),t.deleteProgram(r)}getEquilateralPoints(t,e){return[t.x,t.y+Math.sqrt(3)/3*e,t.x-e/2,t.y-Math.sqrt(3)/6*e,t.x+e/2,t.y-Math.sqrt(3)/6*e]}getChildTrianglePoints(t,e=0){if(0===e)return[[t[0],t[1],(t[0]+t[2])/2,(t[1]+t[3])/2,(t[0]+t[4])/2,(t[1]+t[5])/2],[t[2],t[3],(t[0]+t[2])/2,(t[1]+t[3])/2,(t[2]+t[4])/2,(t[3]+t[5])/2],[t[4],t[5],(t[0]+t[4])/2,(t[1]+t[5])/2,(t[2]+t[4])/2,(t[3]+t[5])/2]];return[...this.getChildTrianglePoints(t,e-1)].reduce(((t,e)=>[...t,...this.getChildTrianglePoints(e)]),[])}drawTriangle(t,e,i,r,n,a,o){this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([e,i,r,n,a,o]),this.gl.STATIC_DRAW);const s=this.gl.FLOAT;this.gl.vertexAttribPointer(t.positionAttributeLocation,2,s,!1,0,0),this.renderTriangle(this.gl)}renderTriangle(t){var e=t.TRIANGLES;t.drawArrays(e,0,3)}}customElements.define("mm-sierpinski",Sierpinski);